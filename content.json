{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"操作系统（七）--死锁","slug":"操作系统（七）-死锁","date":"2019-11-06T11:59:31.000Z","updated":"2019-11-06T14:59:43.568Z","comments":true,"path":"2019/11/06/操作系统（七）-死锁/","link":"","permalink":"http://yoursite.com/2019/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89-%E6%AD%BB%E9%94%81/","excerpt":"","text":"本篇博客分享《操作系统概念》中第七章–死锁部分的学习笔记。死锁是操作系统设计过程中必须着重考虑的一个环节，处理不得当会导致操作系统吞吐量大幅度降低，响应速度慢的结果。作为计算机学习者，我们应该掌握死锁的基本原理，以及如何处理死锁问题。 定义死锁的概念并不难理解，定义如下： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去 必要条件 互斥(mutual exclusion): 至少有一个资源是非共享的，即一次只有一个进程可以使用。这使得一个进程可能为了这个资源而等待另一个占有该资源的进程 占有并等待(hold and wait): 一个进程至少占有一个资源，并等待另一个资源。死锁是由许多进程各自占有对方的资源，又互不相让导致的。一个不占有资源的进程是不会导致死锁的。 非抢占(no preemption): 资源不能抢占。各个进程不给对方资源，却又很礼貌，不抢对方的资源。抢占式资源分配很少出现死锁 循环等待（circle wait）： 有一组等待进程{P0 , P1 , … , Pn},P0等待的资源为P1占有，P1等待的资源为P2占有, …… ,Pn-1等待的资源为Pn占有，Pn等待的资源为P0占有。死锁的资源分配图呈环状 死锁处理方法一般来说，死锁有四种处理方法: 1. 死锁预防 2. 死锁避免 3. 死锁检测与恢复 4. 忽略死锁，手动操作实际上，第四种处理方法看似称不上解决方案，但恰恰为大多数操作系统所采用，包括Linux和Windows。其中，处理死锁的代价是一个重要考量因素。对于许多系统，死锁出现频率很低（甚至一年一次），若使用频繁且开销昂贵的死锁预防、避免或是检测，会浪费大量资源，导致效率低下。相比之下，不处理却是最好的处理，开发人员需自行编写程序，处理死锁即可。 作为学习的需要，了解前三种死锁处理的机制以及分析它们的优缺点对我们大有裨益，以下将详细介绍这三种机制。 死锁预防死锁预防主要从死锁的四个必要条件入手，从根源阻断死锁的产生 互斥 可共享文件不要求互斥访问，因此不会产生死锁。 可读文件便是共享文件的一个例子，当多个文件试图共同读一个文件时，不会产生死锁的问题 但是通常不能通过互斥的角度预防死锁，因为很多资源本身就是非共享的，如互斥锁 持有并等待 该解决方案可理解为all or zero。即每个进程申请资源时，要么获得所有需要的资源，要么什么也得不到。 这种方案确实可以解决死锁问题，但是可能导致资源利用率低与饥饿两种问题 非抢占 改变系统为可抢占模式，则资源不会锁死在不同进程中，可以集中起来服务少数进程，并最终服务完所有进程。 这个协议通常用于状态可保存和恢复的资源，如CPU寄存器和内存。一般不适用于其他资源，如互斥锁和信号量 循环等待 将资源类型完全排序，并要求每个进程按递增顺序来申请资源，这样可以避免资源等待图中环的发生。 但是，设计一个完全排序或层次结构本身不能防止死锁，还要靠应用程序员按顺序编写程序。另外资源排序方式应该按正常使用顺序编排，不可随意排序。 死锁避免1.资源分配图算法 在一个每种资源只有一个实例的资源分配系统中，可用特殊的资源分配图来避免死锁。特殊资源分配图： 除了申请边和分配边（实线），我们引入一个需求边（虚线）。需求边Pi -&gt; Rj表示，进程Pj可能在将来某个时候申请资源Rj。 当请求发生时，需求边变成申请边。 当Pi释放Rj时，分配边变成需求边。 算法依据： 资源分配图中无环，则一定处于安全状态。 资源分配图中有环，则可能处于非安全状态。 算法描述： 假设Pi申请Rj。只有当申请边Pi-&gt;Rj变成分配边Rj-&gt;Pi并且资源分配图中不出现环是，才能允许申请。 银行家算法 适用于每种资源类型有多个实例的资源分配系统。该算法可用于银行系统，可确保银行不会分配现金，以致于它不再满足所有客户的需要。 算法描述： 当一个新的进程进入系统时，它应申明可能需要的每种类型资源实例的最大数量，这一数量不能超过系统资源的总和。当某进程申请一组资源时，系统应确定这些资源的分配是否会使系统不再安全。若是，则该进程等待，直到其他进程释放更多资源。否则，分配资源。死锁检测 每种资源类型只有单个实例： 维护等待图。当且仅当等待图中有环，出现死锁。 每种资源类型有多个实例： 维护类似于银行家算法的多个矩阵图。比较Need矩阵与available向量的大小。 死锁恢复 进程终止1） 终止所有进程：可打破死锁，但是代价巨大。当进程重新计算时，要耗费大量的时间。2） 逐个终止进程，直至消除死锁循环：每次终止一个进程，都将调用死锁检测算法，开销大。并且指定规则，确定每次终止的进程。 资源抢占 资源抢占可解决死锁问题，但是要处理好三个问题： 1） 如何选择牺牲进程：根据代价最小原则确定抢占顺序 2） 回滚：合理处理被抢占进程 3） 饥饿：应设置进程被抢占次数的上限，避免其被无限抢占而节。","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2019-11-05T05:24:38.766Z","updated":"2019-11-05T05:26:55.752Z","comments":true,"path":"2019/11/05/test/","link":"","permalink":"http://yoursite.com/2019/11/05/test/","excerpt":"","text":"h1h2h3h4h5一级标题二级标题 hello1 hello2 hello3 12345public static void main (String args[])&#123; int a,b ; int c = a+b ; System.out.println (c);&#125; github{:target=”_blank”}百度$$ x \\href{why-equal.html}{=} y^2 + 1 $$","categories":[],"tags":[]},{"title":"计算机网络--逻辑链路层","slug":"逻辑链路层","date":"2019-11-05T03:52:24.000Z","updated":"2019-11-06T08:09:18.281Z","comments":true,"path":"2019/11/05/逻辑链路层/","link":"","permalink":"http://yoursite.com/2019/11/05/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"一、概述 数据链路层使用物理层提供的服务在通信信道上发送和接受比特。 二、功能 向网络层提供一个定义良好的服务接口 处理传输错误 调节数据流，确保慢速的接收方不会被快速的接收方淹没 三、服务向网络层提供以下三种服务： 无确认的无连接服务 有确认的无连接服务 有确认的有连接服务 四、成帧 字节计数法 字节填充的标志字节法: 用标志字节FLAG来代表一帧的开始和结束，并用转义字符ESC来解决透明传输问题 例题: Answer: ESC ESC C ESC ESC ESC FLAG G ESC FLAG D 比特填充的标志比特法011111110或十六进制0x7E作为标志字节。若传输的数据遇到连续五个1，则在其后添加一个0，打断六个以上的连续1字节流 物理层编码违禁法","categories":[],"tags":[]},{"title":"my first blog","slug":"my-first-blog","date":"2019-11-05T01:43:15.000Z","updated":"2019-11-05T01:47:55.700Z","comments":true,"path":"2019/11/05/my-first-blog/","link":"","permalink":"http://yoursite.com/2019/11/05/my-first-blog/","excerpt":"","text":"第一章内容 第二章内容 参考文献www.Bryant.cn","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-11-05T01:37:51.841Z","updated":"2019-11-05T01:37:51.841Z","comments":true,"path":"2019/11/05/hello-world/","link":"","permalink":"http://yoursite.com/2019/11/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}