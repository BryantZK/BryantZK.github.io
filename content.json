{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JavaWeb基础（一）--关于Tomcat你必须知道的点","slug":"JavaWeb基础（一）--关于Tomcat你必须知道的点","date":"2020-04-10T01:17:28.964Z","updated":"2020-04-10T01:15:53.444Z","comments":true,"path":"2020/04/10/JavaWeb基础（一）--关于Tomcat你必须知道的点/","link":"","permalink":"http://yoursite.com/2020/04/10/JavaWeb%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89--%E5%85%B3%E4%BA%8ETomcat%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E7%82%B9/","excerpt":"","text":"JavaWeb基础（一）–关于Tomcat你必须知道的点1.概述几款流行的web服务器： webLogic: Oracle公司，大型JavaEE服务器，支持所有javaEE规范，收费 webSphere: IBM公司，大型JavaEE服务器，支持所有javaEE规范，收费 JBOSS: JBOSS公司，大型JavaEE服务器，支持所有javaEE规范，收费 Tomcat: Apache基金组织，中小型JavaEE服务器，支持少量javaEE规范，免费 2.安装与卸载安装只需下载压缩包并解压即可。 卸载同样只需删除解压后的文件夹即可。 3.Tomcat目录结构其实大多数软件都有类似的结构，掌握了Tomcat的，对日后学习新的技术也大有裨益 bin：存放可执行文件 conf：存放配置文件 lib：存放依赖jar包 logs：存放日志文件 temp：存放临时文件 webapps：存放web项目 work：存放运行时数据 4.启动双击运行bin/start.bat，在浏览器中输入：http://localhost:8080,即可访问tomcat默认项目页面。 在chrome、Firefox等高级浏览器中可省略http: localhost = 128.0.0.1 8080是端口号，可在配置文件conf/server.xml中更改 若将默认端口号8080改成80，则可直接通过http://localhost访问。因为80是http的默认端口号 5.启动时可能遇到的问题 双击start.bat后，黑窗口一闪而过： 原因：没有正确配置JAVA_HOME系统变量 解决方法：正确配置JAVA_HOME系统变量并添加至path中 启动时，端口号占用 1)暴力解决：杀死占用者 1.在cmd命令中输入 netstat -ano，查看占用8080端口的PID（进程号） 2.在任务管理其中，找到PID对应的进程，并杀死即可 2)温柔解决：改变自身端口 更改配置文件server.xml中的默认端口号 6.关闭 正常关闭： 在黑窗口中 ctrl+c 双击运行bin/shutdown.bat 强制关闭： 点击x，直接关闭黑窗口 7.部署项目 直接将项目放在webapps目录下 访问路径：localhost:项目名/文件名 简化部署：将项目打成war包。war包是一种特殊的压缩包，不仅体积小，而且在被复制进webapps后会自动解压缩 配置conf/server.xml（不安全，不推荐使用） 在server.xml中添加 1&lt;Context base=\"项目路径\" path =\"项目名\"&gt;&lt;/Context&gt; 在confi/Catalina/localhost文件夹下创建任意名称的xml文件。（推荐） 在文件中编写 1&lt;Context docBase=\"路径\"&gt;&lt;/Context&gt;","categories":[],"tags":[]},{"title":"使用serialize()提交form表单数据后台为null问题解决","slug":"使用serialize()提交form表单数据后台为null问题解决","date":"2020-04-04T04:57:03.613Z","updated":"2020-04-04T04:56:30.199Z","comments":true,"path":"2020/04/04/使用serialize()提交form表单数据后台为null问题解决/","link":"","permalink":"http://yoursite.com/2020/04/04/%E4%BD%BF%E7%94%A8serialize()%E6%8F%90%E4%BA%A4form%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E5%90%8E%E5%8F%B0%E4%B8%BAnull%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"使用serialize()提交form表单数据后台为null问题解决今天在完成新增账户功能时，利用jQuery的serialize方法，希望将整张表的数据传至后台，收到的数据却全部为null： 1234567891011121314&lt;form class=\"form-horizontal\" id=\"account_add_form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"accountName_add_input\" class=\"col-sm-2 control-label\"&gt;Name&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"accountName_add_input\" placeholder=\"accountName\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"accountMoney_add_input\" class=\"col-sm-2 control-label\"&gt;Money&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"accountMoney_add_input\" placeholder=\"accountMoney\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 123456789101112$(\"#account_save_btn\").click(function()&#123; var form = $(\"#account_add_form\").serialize() console.log(form); alert(form); //1.模态框种填写的表单数据提交给服务器进行保存 //2.发送ajax请求保存员工 $.ajax(&#123; url:\"/account/save\", type:\"POST\", data:form &#125;); &#125;); 问题分析: 1.console.log可以将结果打印至控制台,但是alert没有反应 2.上网查找资料,发现是表单的input中没有加入name属性,只有id属性 ​ 于是,添加了name属性,但是属性值与后台Account类的属性名不一致. ​ 此时:alert有反应,但后台得到的数据为null,即没有成功封装 3.将name属性值与Account类的属性名保持一致, ​ 封装成功,问题解决! 成功代码: 1234567891011121314&lt;form class=\"form-horizontal\" id=\"account_add_form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"accountName_add_input\" class=\"col-sm-2 control-label\"&gt;Name&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"accountName_add_input\" name=\"name\" placeholder=\"accountName\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"accountMoney_add_input\" class=\"col-sm-2 control-label\"&gt;Money&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"accountMoney_add_input\" name=\"money\" placeholder=\"accountMoney\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;","categories":[],"tags":[]},{"title":"SpringMVC学习笔记（二）","slug":"SpringMVC学习笔记（二）","date":"2020-02-26T02:54:49.174Z","updated":"2020-02-26T02:53:50.005Z","comments":true,"path":"2020/02/26/SpringMVC学习笔记（二）/","link":"","permalink":"http://yoursite.com/2020/02/26/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"SpringMVC学习笔记（二）一、请求参数的绑定​ SpringMVC绑定请求参数的过程是通过把表单提交的请求参数，作为控制器中方法参数进行绑定的。 ​ 请求参数类型有三种：1）基本类型数据 2）实体类对象 3）数组和集合类型数据 1.基本类型数据 ​ 基本类型数据包括了Java的基本类型以及String类型 ​ 示例程序： 1&lt;a href=\"param/testParam?username=hehe&amp;password=123456\"&gt;请求参数绑定&lt;/a&gt; 123456@RequestMapping(\"/testParam\") public String testParam(String username,String password)&#123; System.out.println(\"执行了。。。\"); System.out.println(\"你的用户名：\" + username + \" 你的密码：\" + password); return \"success\" ; &#125; 2.实体类对象 ​ 将数据封装成实体类对象，也同样很简单。只需要令接收端Controller类方法以被封装类为参数，发送端jsp中将属性名与被封装类的属性名相同即可。 ​ 示例程序： 12345678910public class Account implements Serializable &#123; private String username ; private String password ; private Double money ; private User user ; /** *省略getter、setter、toString方法 */&#125; 1234567public class User implements Serializable &#123; private String uname ; private Integer age ; /** *省略getter、setter、toString方法 */&#125; 12345678910/** * 把请求参数封装到一个Java类中 * @return */ @RequestMapping(\"/saveAccount\") public String saveAccount(Account account)&#123; System.out.println(\"执行了。。。\"); System.out.println(account); return \"success\" ; &#125; 123456789&lt;form action=\"param/saveAccount\" method=\"post\"&gt; 性名：&lt;input type=\"text\" name=\"username\"&gt; 密码：&lt;input type=\"text\" name=\"password\"&gt; 金额：&lt;input type=\"text\" name=\"money\"&gt; 用户性名：&lt;input type=\"text\" name=\"user.uname\"&gt; 用户年龄：&lt;input type=\"text\" name=\"user.age\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; 3.数组或集合类型 ​ 数组或集合类型的封装与嵌套对象及其类似，同样十分简单 ​ 示例程序： 1234567891011public class Account implements Serializable &#123; private String username ; private String password ; private Double money ; private List&lt;User&gt; list ; private Map&lt;String,User&gt; map ; /** *省略getter、setter、toString方法 */&#125; 12345678910/** * 把请求参数封装到一个Java类中 * @return */ @RequestMapping(\"/saveAccount\") public String saveAccount(Account account)&#123; System.out.println(\"执行了。。。\"); System.out.println(account); return \"success\" ; &#125; 123456789101112&lt;%-- 把数据封装到Account类中，类中存在list和map的集合 --%&gt; &lt;form action=\"param/saveAccount\" method=\"post\"&gt; 性名：&lt;input type=\"text\" name=\"username\"&gt; &lt;br/&gt; 密码：&lt;input type=\"text\" name=\"password\"&gt; &lt;br/&gt; 金额：&lt;input type=\"text\" name=\"money\"&gt; &lt;br/&gt; 用户性名：&lt;input type=\"text\" name=\"list[0].uname\"&gt; &lt;br/&gt; 用户年龄：&lt;input type=\"text\" name=\"list[0].age\"&gt; &lt;br/&gt; 用户性名：&lt;input type=\"text\" name=\"map['one'].uname\"&gt; &lt;br/&gt; 用户年龄：&lt;input type=\"text\" name=\"map['one'].age\"&gt; &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; 4.配置解决中文乱码的过滤器 ​ 当通过表单使用post方式发送中文数据时，会在控制台出现乱码的问题。 ​ 要解决上述问题，只需在web.xml中配置一个过滤器即可 12345678910111213&lt;!-- 配置解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 5.特殊情况 ​ 在实际开发过程中，有可能会面临前台传入的数据，与后台接受类型封装不上的情况。这时候，我们需要编写自定义的数据类型转换方法，并且向类型转换器注册，最后开启注册生效按钮。 ​ 示例：在接受Date数据时，默认格式是yyyy/mm/dd,当我们以yyyy-mm-dd的形式传入时，会出现封装不上的情况。所以我们编写一个自定义的转换方法，并向类型转换器注册,最后开启注册生效按钮即可。 12345678910111213141516public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String s) &#123; //判断 if(s == null)&#123; throw new RuntimeException(\"请您传入数据\"); &#125; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); try &#123; return sdf.parse(s); &#125; catch (Exception e) &#123; throw new RuntimeException(\"数据类型转换出现错误\"); &#125; &#125;&#125; 12345678&lt;!-- 配置自定义类型转换器 --&gt; &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\" &gt; &lt;set&gt; &lt;bean class=\"cn.itcast.utils.StringToDateConverter\"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 1&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt; 6.获取Servlet原生API ​ 想要获取Servlet原生API，直接将ServletAPi对象作为控制器方法的参数即可。 二、常用注解1.RequestParam ​ 作用： ​ 把请求中指定名称的参数给控制器中的形参赋值。 ​ 属性： ​ value：请求参数的名称 ​ required：请求参数中是否必须提供此参数。默认值：true，表示必须提供，如不提供则报错 2.RequestBody ​ 作用： ​ 用于获取请求体内容。如果直接使用请求体，则会得到key=value&amp;key=value…结构的数据 ​ get请求方式不适用 ​ 属性： ​ required：是否必须有请求体。默认值是，true。当取值为true时，get请求方式会报错。取值为false时，get请求方式得到的是null 3.PathVariable ​ 作用： ​ 用于绑定url中的占位符。例如：请求url中/delete/{id},这个id就是url占位符 ​ url支持占位符是Spring3.0之后加入的。是springmvc支持RESTful风格url的一个重要标志 ​ 属性： ​ value：用于请求url中占位符的名称 ​ required：是否必须提供占位符 4.CookieValue ​ 作用： ​ 用于把指定cookie名称的值传入控制器方法参数 ​ 属性： ​ value：指定cookie的值 ​ required：是否必须有此cookie","categories":[],"tags":[]},{"title":"SpringMVC学习笔记（一）","slug":"SpringMVC学习笔记（一）","date":"2020-02-25T02:59:54.451Z","updated":"2020-02-25T02:59:07.866Z","comments":true,"path":"2020/02/25/SpringMVC学习笔记（一）/","link":"","permalink":"http://yoursite.com/2020/02/25/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"SpringMVC学习笔记（一）一、SpringMVC概述1.概念 ​ SpringMVC是一种基于Java的MVC设计模型的请求驱动类型的轻量级Web框架，属于Spring Framework的后续产品，已经融合在Spirng Web Flow中。使用Spring可插入的MVC架构，从而在使用Spring进行WEB开发时，可以选择SpringMVC或其他MVC集成开发框架，如Strut1（基本弃用），Struts2等。 ​ SpringMVC已经成为最主流的MVC框架之一，并随着Spring3.0的发布，全面超越Struts2，成为最优秀的MCVC框架。 ​ SpringMVC通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。 ​ SpringMVC支持RESTful编程风格的请求。 2.优势 1、清晰的角色划分： ​ 前端控制器（DispatcherServlet） ​ 请求到处理器映射（HandlerMapping） ​ 处理器适配器（HandlerAdapter） ​ 视图解析器（ViewResolver） ​ 处理器或页面控制器（Controller） ​ 验证器（ Validator） ​ 命令对象（Command 请求参数绑定到的对象就叫命令对象） ​ 表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 3、由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。 4、和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 5、可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 6、可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。 7、功能强大的数据验证、格式化、绑定机制。 8、利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。 10、强大的 JSP 标签库，使 JSP 编写更容易。 3.SpringMVC与Struts2的比较（面试） ​ 共同点： 1）都是表现层框架，都是基于MVC模型编写的 2）底层都离不开原始ServletAPI 3）处理请求的机制都是一个核心控制器 ​ 不同点： 1）SpringMVC的入口是Servlet，Struts2的入口是Filter 2）SpringMVC执行速度稍快。SpringMVC是基于方法设计的，而Struts2是基于类，每次执行都会动态创建一个动作类 3）SpringMVC的使用更加简洁，同时还支持JSR303，处理ajax的请求更方便 4）Struts2由于支持OGNL表达式，其开发效率更高，但是执行效率并没有SpringMVC高 二、SpringMVC入门程序​ 言归正传，接下来我们开始编写SpringMVC的入门程序。前四步为环境搭建，后两步为程序编写 1.创建Maven项目 ​ 打开IDEA，创建一个Maven的web-app项目。并在src目录下创建一个java目录（标记目录类型为：Sources Root）与一个resources目录（标记目录类型为Resources Root） 2.配置pom.xml，导入jar包坐标 ​ 在&#60;properties&#62;中,添加版本锁定 1234567&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!-- 版本锁定 --&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; ​ 在&#60;dependencies&#62;添加以下依赖 1234567891011121314151617181920212223242526272829&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.配置web.xml，获取servlet核心控制器 1234567891011121314151617&lt;!-- 配置SpringMVC核心控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，用于读取SpringMVC的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置Servlet对象的创建时间：应用加载时创建。 取值只能是非0正整数，表示启动顺序--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 4.创建SpringMVC配置文件 ​ 首先在Resources目录下创建springmvc.xml，然后所需的导入约束，最后配置创建Spring容器要扫描的包、视图解析器、处理映射器、处理适配器。 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"cn.itcast\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启SpringMVC框架注解的支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 5.编写Controller方法并使用注解配置 12345678@Controller(\"helloController\")public class HelloController &#123; @RequestMapping(\"/hello\") public String sayHello() &#123; System.out.println(\"HelloController 的 sayHello 方法执行了。。。。\"); return \"success\"; &#125; &#125; 6.用jsp 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;入门程序&lt;/h3&gt; &lt;a href=\"hello\"&gt;入门程序&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 三、入门案例流程分析​ 1.服务器启动，加载web.xml配置，创建DispatcherServlet对象 ​ 2.加载springmvc.xml文件，创建SprigIOC容器，视图解析器，处理映射器，处理适配器等 ​ 3.浏览器发送请求，被DispatcherServlet捕获，并转发给处理映射器，匹配@RequestMapping注解内容，获取应该执行的方法(HelloController类中的sayHello方法)。 ​ 4.通过处理适配器，执行已获取的方法，并返回方法的返回值（success） ​ 5.DispatcherServlet再将返回值交给视图解析器处理，得到一个结果视图(success.jsp) ​ 6.渲染结果视图，相应浏览器 四、入门案例设计的SpringMVC组件1.DispatcherServlet：前端控制器 ​ 用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 2.HandlerMapping：处理映射器 ​ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等 3.HandlerAdapter:处理适配器 ​ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 4.ViewResolver：视图解析器 ​ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户 5.&#60;mvc:annotation-driven&#62;说明 ​ 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 ​ 使用mvc:annotation-driven自动加载 RequestMappingHandlerMapping（处理映射器）和 RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用 mvc:annotation-driven替代注解处理器和适配器的配置。 五、RequestMapping注解1.出现位置 ​ 由于@RequestMapping的元注解@Target中包含了ElementType.Method和ElementType.TYPE,所以此注解可以出现在方法或者类上 2.value与path属性 ​ value与path是等价的，都用于指定执行此方法的获取路径 3.method属性 ​ 用于指定请求的方式，常见的值有RequestMethod.POST、RequestMethod.GET、RequestMethod.PUT、RequestMethod.DELETE等 4.param属性 ​ 用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。 ​ 例如： ​ params = {“accountName”}，表示请求参数必须有 accountName ​ params = {“moeny!100”}，表示请求参数中 money 不能是 100。 5.headers属性 ​ 用于指定限制请求消息头的条件 ​","categories":[],"tags":[]},{"title":"JavaWeb基础（二）--Cookie与Session","slug":"JavaWeb基础（二）--Cookie与Session","date":"2020-02-22T12:05:10.799Z","updated":"2020-02-22T12:03:45.464Z","comments":true,"path":"2020/02/22/JavaWeb基础（二）--Cookie与Session/","link":"","permalink":"http://yoursite.com/2020/02/22/JavaWeb%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89--Cookie%E4%B8%8ESession/","excerpt":"","text":"Java基础强化（四）–Cookie与Session一、会话技术​ 1.概念 ​ 会话是指浏览器与服务器之间的信息交互。 ​ 会话从浏览器第一次给服务器资源发送请求开始，知道有一方断开结束。一次会话包括多次请求与响应。 ​ 2.功能： ​ 在一次会话的范围内，共享数据 ​ 3.方式： ​ 1）客户端会话技术：Cookie ​ 2）服务器端会话技术：Session 二、Cookie​ 1.概念 ​ 客户端会话技术，将数据保存到客户端 ​ 2.快速入门 ​ 在Demo1中创建并发送cookie 1234//创建cookie对象，调用new Cookie(String name,String value)Cookie cookie = new Cookie(name,\"张三\");//发送cookie对象,调用response.addCookie(Cookie cookie)response.addCookie(cookie); ​ 在Demo2中获取Cookie 12//获取cookie，调用 Cookie[] request.getCookies()Cookie[] cookies = request.getCookies() ​ 3.Cookie实现原理 ​ 基于响应头set-cookie和请求头cookie实现 ​ 4.cookie的细节 ​ 1）可以一次创建多个cookie，使用response调用多次addCookie方法发送cookie即可 ​ 2）生命周期： 默认情况下，关闭浏览器之后，cookie数据被销毁 持久化存储： ​ setMaxAge(int seconds) ​ a.seconds为正数：将Cookie数据写到硬盘文件中，即持久化存储。数值越大，存活时间越长 ​ b.seconds为负数：默认值，存在内存中，关闭浏览器，即销毁 ​ c.seconds为零：删除Cookie信息 ​ 3）在Tomcat 8之前，Cookie中不能直接存储中文数据。 ​ –需要将中文数据转码（一般采用url） ​ 在8之后，Cookie支持中文数据 ​ 4）共享问题 ​ 在同一个Tomcat服务器中，部署多个web项目，默认情况下各个项目的Cookie是不能被其他项目共享的 ​ 如果需要共享，那么可以通过调用setPath(String path)方法来改变Cookie的获取范围，将其设置为”/“，即服务器根目录 ​ 写法示例： 1234//创建Cookie对象Cookie c1 = new Cookie(\"msg\",\"你好\");//设置Path，令当前服务器下部署的所有项目共享Cookie信息c1.setPath(\"\\\") ​ 在不同Tomcat服务器下部署的服务器若要实现共享，则需要调用setDomain(String Path)方法 ​ 只要不同服务器之间的一级域名相同，则将path设置为以及域名，这些web项目即可共享kookie ​ 示例： 1234//创建Cookie对象Cookie c1 = new Cookie(\"msg\",\"你好\");//设置domain,令tieba.baidu.com与new.baidu.com中cookie可以共享c1.setDomain(\".baidu.com\") ​ 5.Cookie特点 ​ 1）Cookie数据存储在客户端浏览器，安全性不强 ​ 2）浏览器对单个Cookie大小有限制，并对同一个域名下的总Cookie数也有限制（一般20） ​ 6.Cookie作用 ​ 1）Cookie一般用在存储少量不太敏感的数据 ​ 2）在不登陆的情况下，完成服务器对客户端的身份识别 三、Session​ 1.概念： ​ 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象 ​ 2.快速入门 ​ 1）获取HttpSession对象： ​ HttpSession session = request.getSeesion(); ​ 2) 使用HttpSession对象： ​ Object getAttribute(String name); ​ void setAttribute(String name,Object value); ​ void removeAttribute(String name); ​ 3.原理 ​ Session是依赖于Cookie的 第一次获取Session时，没有Cookie，会在内存中创建一个新的Session对象。并在Cookie中保存该session的地址。 在第二次获取Session时，Cookie会被客户端浏览器发送到服务器端，服务器端会去根据Cookie中的Session地址查找Session对象。 ​ 4.细节 ​ 1）在第一次访问结束后，关闭客户端，不关闭服务器。再重新打开客户端，访问服务器。那么，两次访问的session是否为同一个？ 默认情况下，不是 如果要求为同一个，则可以创建Cookie，键为JSESSIONID，设置最大存活时间，让cookie持久化保存 123&gt;Cookie c - new Cookie (\"JSESSIONID\",session.getId());&gt;c.setMaxAge(60 * 60);&gt;response.addCookie(c); ​ 2）在第一次访问结束后，关闭服务器，不关闭客户端。再重新打开服务器，并让客户端访问服务器。那么，两次访问的session是否为同一个？ 不是同一个，但是我们要确保数据不丢失 session的钝化： 再服务器正常关闭之前，将session对象系列化到硬盘上 session的活化： 再服务器启动之后，将session文件转化为内存中的session对象即可 session的活化与钝化，本地Tomcat服务器会自动帮我们完成。 但是如果使用IDEA工具，钝化的操作可以正常执行，活化的工作无法正常执行。 但是我们也不用担心这个问题，因为未来我们不可能在IDEA本地进行部署。 ​ 3.Session的销毁 ​ 1)服务器被关闭时，session失效 ​ 2)session的自杀方法：invalidate() ​ 3)session默认失效时间：30分钟（可在web.xml中配置） ​ 4.Session的特点、 ​ 1）用于存储一次会话的多次请求的数据，存在服务器端 ​ 2）Session可以存任意类型，任意大小的数据 ​ 3）Session数据安全，Cookie相对不安全","categories":[],"tags":[]},{"title":"JavaWeb基础（三）-- EL与JSTL","slug":"JavaWeb基础（三）-- EL与JSTL","date":"2020-02-20T12:43:57.180Z","updated":"2020-02-20T12:43:27.004Z","comments":true,"path":"2020/02/20/JavaWeb基础（三）-- EL与JSTL/","link":"","permalink":"http://yoursite.com/2020/02/20/JavaWeb%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89--%20EL%E4%B8%8EJSTL/","excerpt":"","text":"Java基础强化（三）– EL与JSTL​ EL与JSTL是Jsp开发中常用的两个简化开发的小工具，在日后的框架学习中也有可能用到。内容比较简单，主要罗列知识点，JSTL部分有示例代码，El部分容易理解，不给出实例代码。有学习兴趣的同学可以自行落实代码，加强学习。 一、EL概述​ 1.概念： ​ Expression Language 表达式语言 ​ 2.作用： ​ 替换和简化jsp页面中的java代码的编写 ​ 3.语法： ​ ${表达式} ​ 4.忽略El： 设置jsp中page指令：isELIgnored=“true” 忽略当前jsp页面中所有的el表达式 \\${表达式}:忽略当前el表达式 二、EL使用​ 1.运算： ​ El表达式支持以下运算符： 1.算数运算符： + - * /(div) %(mod) 2.比较运算符：&gt; &lt; == &gt;= &lt;= != 3.逻辑运算符：&amp;&amp;(and) ||(or) !(not) 4.空运算符：empty(用于判断字符串、集合或数组对象是否为null或长度为0) ​ 举例： ​ ${empty list} 判断list是否为nul或长度为0，若是则返回true ​ ${not empty list} 判断list是长度大于0，若是则返回true ​ 2.获取值 ​ el表达式只能从域中获取对象的值 ​ 语法： 1.${域名.键名}:从指定域中获取指定键的值 ​ 域名称： ​ (1)pageScope –&gt; pageContext ​ (2)requestScope –&gt;request ​ (3)sessionScope –&gt;session ​ (4)applicationScope –&gt;application(ServletContext) ​ 举例： ​ 在request域中存储了name=张三 ​ 则可以通过${requestScope.name}的EL表达式获取张三 2.${键名}:以此从最小的域中查找是否有该键名对应的值，找到即停止 3.获取对象、List集合、Map集合的值 (1)对象：${域名.对象名.属性名} ​ 属性名不是成员变量的名称，而是get方法的名称去掉get再将首字母改为小写 ​ 其本质是调用对象的get方法 (2)List集合：${域名称.键名[索引]} (3)Map集合： ​ ${域名称.键名.key名称} ​ ${域名称.键名.[“key名称”] 三、JSTL概述​ 1.概念：JavaServer Pages Tag Library JSP标准标签（apache组织提供的开源的免费的jsp标签） ​ 2.作用：用于替换和简化jsp页面上的java代码 ​ 3.使用步骤： ​ （1）导入jstl相关jar包 ​ （2）引入标签库：taglib指令： &lt;%@ taglib %&gt; ​ 具体写法是在jsp页面上添加一句如下语句： 1&lt;% taglib prefix=\"c\" url=\"http://java.sun.com/jsp/jstl/core\" %&gt; ​ （3）使用标签 四、JSTL常用标签​ 1.if ​ &#60;c:if&#62;标签: 用于代替if语句 属性： test，必备属性，接受一个boolean表达式* 若表达式为真，则显示标签体的内容。若表达式为假，则不显示标签体的内容 ​ 示例代码： 12&lt;c:if test=\"1==2\"&gt;1等于2&lt;/c:if&gt;&lt;c:if test=\"1==1\"&gt;1等于1&lt;/c:if&gt; ​ 上述代码显示”1等于1” ​ 2.choose ​ &#60;c:choose &#62; 标签用于代替switch语句 ​ &#60;c:when&#62;相当于case ​ &#60;c:otherwise&#62;相当于defualt ​ 示例代码： 123456789101112131415161718192021&lt;%-- 完成数字编号对应星期几的案例 1.域中存储数字 2.使用choose标签取出数字 3.使用when标签做出数字判断 4.使用otherwise标签做其他情况处理 --%&gt;&lt;% request.setAttribute(\"number\",3);%&gt;&lt;c:choose&gt; &lt;c:when test=\"$&#123;requestScope.number&#125; == 1\"&gt;星期一&lt;/c:when&gt; &lt;c:when test=\"$&#123;requestScope.number&#125; == 2\"&gt;星期二&lt;/c:when&gt; &lt;c:when test=\"$&#123;requestScope.number&#125; == 3\"&gt;星期三&lt;/c:when&gt; &lt;c:when test=\"$&#123;requestScope.number&#125; == 4\"&gt;星期四&lt;/c:when&gt; &lt;c:when test=\"$&#123;requestScope.number&#125; == 5\"&gt;星期五&lt;/c:when&gt; &lt;c:when test=\"$&#123;requestScope.number&#125; == 6\"&gt;星期六&lt;/c:when&gt; &lt;c:when test=\"$&#123;requestScope.number&#125; == 7\"&gt;星期日&lt;/c:when&gt; &lt;c:otherwise&gt;数字输入错误&lt;/c:otherwise&gt;&lt;/c:choose&gt; ​ 上述代码的显示结果为 “星期三” ​ 3.foreach ​ &#60;c:foreach&#62;相当于java中的for语句 java代码中for语句的作用： ​ 1.完成重复的操作 for（int i=1；i&lt;10;i ++){ } ​ 2.遍历容器 List list; for(User user:list){ } 属性： begin：开始值 end：结束值 var：临时变量 step：步长 varStatus：循环状态对象 * index：容器中元素的索引，从0开始 * count：循环次数，从1开始 item:容器对象 ​ 示例代码（1）： 123&lt;c:foreach begin=\"1\" end=\"10\" var=\"i\" step=\"1\"&gt; $&#123;i&#125;&lt;/c:foreach&gt; ​ 显示结果: 12345678910 ​ 示例代码（2）： 1234567891011&lt;% List list = new ArrayList(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); request.setAttribute(\"list\",list);%&gt;&lt;c:foreach item=\"$&#123;list&#125;\" var=\"strs\" varStatus=\"s\"&gt; $&#123;s.index&#125; $&#123;s.count&#125; $&#123;strs&#125; &lt;br&gt;&lt;/c:foreach&gt; ​ 显示结果： 0 1 aaa 1 2 bbb 2 3 ccc","categories":[],"tags":[]},{"title":"Java基础强化（二） -- 注解","slug":"Java基础强化（二） -- 注解","date":"2020-02-20T00:45:35.285Z","updated":"2020-02-20T00:45:15.891Z","comments":true,"path":"2020/02/20/Java基础强化（二） -- 注解/","link":"","permalink":"http://yoursite.com/2020/02/20/Java%E5%9F%BA%E7%A1%80%E5%BC%BA%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%20--%20%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"Java基础强化（二） – 注解一、注解概述​ 1.定义 ​ 注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 ​ 2.作用描述 ​ （1）编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查[@Override] ​ （2）编写文档：通过代码里的标识的注解生成doc文档 ​ （3）代码分析：通过代码里标识的注解对代码进行分析[使用反射] ​ 3.JDK中预定义的注解 ​ @Override：检测被改注释标注的方法是否是继承自父类（接口）的 ​ @Deprecated：该注解标注的内容，标识已过时。即虽然可以使用，但是不推荐使用 ​ @SuppressWarnings：压制警告 ​ *一般传递参数all，@SuppressWarnings(“all”) 二、自定义注解​ 1.格式 1234元注解public @interface 注解名称&#123; 属性列表;&#125; ​ 2.本质 ​ 注解本质是一个接口，该接口默认继承Annotation接口 &gt; &gt; &gt;假设按照上述1.格式自定义一个接口My Anno，并通过反编译的方式，我们会得到一下结果 &gt; &gt;public interface MyAnno extends java.lang.annotation.Annotation{}​ 3.属性：接口中的方法 ​ 要求： ​ （1）属性的返回值有一下列取值 基本数据类型 String 枚举 注解 上述类型的数组 ​ 1234567public @interface MyAnno&#123; int show1 (); String show2(); Person show3() default \"Person.p1\"; @Override show4(); String[] show5();&#125; ​ （2）定义了属性，在使用时需要给属性赋值 ​ （a)如果定义属性时，使用default 关键字给属性默认初始化，则使用注解时，可以不进行属性的赋值 ​ （b)如果只有一个属性需要赋值，且这个属性名称是value，则“value=”可以省略，直接定义值即可 ​ （c)数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 1234@MyAnno(show1=1,show2=\"hello\",show4=@Override,show5=&#123;\"abc\",\"bcd\"&#125;)public class show&#123; &#125; ​ 4.元注解：用于描述注解的注解 ​ 常用的元注解有四个： @Target : 描述注解能够作用的位置 ​ ElementType的取值： * Type：表示注解可以作用于类上 * Method：表示注解可以作用于方法上 * Field：表示注解可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention（RetentionPolicy.RUNTIME）：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 @Documented：描述注解是否被抽取到API文档中 @Inherited：描述注解是否被子类继承 ​ 5.程序中对注解的解析 ​ 在程序中使用（解析）注解，获取注解中定义的属性值 ​ （1）获取被注解的对象（类，方法，成员变量等） ​ （2）获取指定的注解 ​ 通过getAnnotation(class)方法 ​ （3）调用注解中的抽象方法来获取配置的属性值 ​ 示例程序： ​ 首先定义一个Prop注解，有两个属性：className用来存储类名，methodName用来存储方法名 123456@Target(\"ElementType.Type\")@Retention(RetentionPolicy.RUNTIME)public @interface Prop&#123; String className(); String methodName() ;&#125; ​ 则我们可以按如下方式使用并调用注解中的属性。 123456789101112@Prop(className=\"cn.itcast.annotation.Demo1\",methodName=\"show\")public class ReflectTest &#123; public static void main (String [] args) throws Exception&#123; //获取被注解的类字节码文件 Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class ; //获取类上的注解对象 Prop prop = reflectTestClass.getAnnotation(Prop.class); //调用注解对象中定义的抽象方法，获取属性 String className = prop.className(); String methodName = prop.methodName(); &#125;&#125; ​ 对于以上程序调用我们可以理解成Java为我们自动生成了一个如下的Prop实现类： 12345678public class PropImpl implments Prop&#123; public String className()&#123; return \"cn.itcast.annotation.Demo1\"; &#125; public String methodName()&#123; return \"show\" ; &#125;&#125;","categories":[],"tags":[]},{"title":"Java基础强化（一） -- 反射","slug":"Java基础强化（一） -- 反射","date":"2020-02-19T06:00:55.127Z","updated":"2020-02-20T00:47:35.119Z","comments":true,"path":"2020/02/19/Java基础强化（一） -- 反射/","link":"","permalink":"http://yoursite.com/2020/02/19/Java%E5%9F%BA%E7%A1%80%E5%BC%BA%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%20--%20%E5%8F%8D%E5%B0%84/","excerpt":"","text":"Java基础强化（一） – 反射​ 在学习完MyBatis与Spring技术之后，笔者决定先去巩固一些之前不牢固的java以及javaWeb基础。主要内容包括：反射、注解、并发与线程、servlet、request、response、EL表达式、JSTL、监听器、过滤器、Maven。在扎实基础之后，再前往学习Spring的后续内容。 一、反射概述​ 1.反射：框架设计的灵魂 框架：半成品软件。在框架的基础上开发，可以简化编码。 反射：将类的各个组成部分封装为其他对象，这就是反射机制 ​ 2.好处： ​ （1）便于程序在运行过程中操作这些对象。 ​ （2）可以解耦，提高程序的可扩展性 ​ 3.获取Class对象的方法: ​ （1）Class.forName(“全类名”)：将字节码加载进内存，返回Class对象 ​ 多用于配置文件，将全类名定义在配置文件中。读取文件，加载类即可 ​ （2）类名.class:通过类名的属性class获取 ​ 多用于参数的传递 ​ （3）对象.getClass():getClass是Object类中的方法 ​ 多用于凭借对象获取字节码 ​ 同一个字节码文件(*.class)在一次运行过程中，只会被加载一次，不论通过上述哪种方式获取class对象，结果都是同一个 二、Class对象的功能​ 1.获取成员变量 12345678/*返回一个Filed对象数组，保存本类及其父类的public成员变量*/Field [] getFields();/*返回一个Filed对象，该对象是指定名称的本类或父类public成员变量*/Filed getFiled(String name);/*返回一个Filed对象数组，保存本类的任意访问权限的成员变量*/Filed [] getDeclaredFileds();/*返回一个Filed对象，该对象是指定类名的本类的任意访问权限的成员变量*/Filed getDeclaredFiled(String name) ; ​ 2.获取构造函数 12345678/*返回Class对象类的所有public构造器*/Construcator [] getConstructors();/*返回Class对象类中的指定名字的public构造器*/Constructor getConstructor(String name);/*返回Class对象类中所有构造器*/Constructor [] getDeclaredConstructors();/*返回Class对象类中指定名字的构造器*/Constructor getDeclaredConstructor(String name); ​ 实例程序： 123456789101112/*创建Teacher的Class对象类*/Class class5 = Class.forName(\"domain.Teacher\");/*获取Teacher的所有构造函数*/Constructor []constructors = class5.getConstructors(); //teacher中有两个构造函数/*打印Teacher的所有构造函数*/for(Constructor constructor : constructors)&#123; System.out.println(constructor);&#125; /*public domain.Teacher()public domain.Teacher(java.lang.String,java.lang.Integer)*/ ​ 3.获取成员方法 12345678/*获取Class对象类与其父类的所有public方法*/Method [] getMethods();/*获取Class对象类与其父类的指定名称的public方法*/Method getMethod (String name);/*获取Class对象类的所有方法*/Method[] getDeclaredMethods()/*获取Class对象类的指定名称的方法*/;Method getDeclaredMethod(String name); ​ 实例程序 12345678910111213/*创建Teacher的Class对象类*/Class class5 = Class.forName(\"domain.Teacher\");/*获取Teacher类中的无参teach方法*/Method method1 = class5.getMethod(\"teach\");/*获取Teacher类中的有参teach方法*/Method method2 = class5.getMethod(\"teach\", String.class);/*打印Teacher类中的两个teach方法*/System.out.println(method1);System.out.println(method2);/* public void domain.Teacher.teach() public void domain.Teacher.teach(java.lang.String)*/ 4.获取类名 1String getName(); 三、Filed类​ Filed类的常用方法 ​ (1) Object get(Object obj); ​ 获取obj对象中该成员变量的值. 1234567891011/*创建Teacher类的实例化对象teacher1*/Teacher teacher1 = new Teacher();/*将teacher1中name的值设成\"李老师\"*/ teacher1.setName(\"李老师\");/*获取Teacher的Class对象类*/ Class class0 = Class.forName(\"domain.Teacher\");/*获取Teacher中的name成员变量*/ Field name = class0.getField(\"name\");/*打印Teacher中的name成员变量*/ System.out.println(name.get(teacher1));/*李老师*/ ​ (2) void set(Object obj,Object value); ​ 将obj对象中该成员变量的值设成value 12345 /*通过field的set方法将teacher1对象的name值设成\"王老师\"*/name.set(teacher1,\"王老师\");/*打印Teacher中的name成员变量*/ System.out.println(name.get(teacher1));/*王老师*/ ​ (3)setAccessible(boolean flag); ​ 若程序要访问私有成员变量的值，则需要通过本函数进行访问权限设置，即暴力反射 1234567/*将对象teacher1的age值设成40*/teacher1.setAge(40);/*获取Teacher中的age成员变量*/ Field age = class.getDeclaredField(\"age\");//age为私有变量，不能用getField函数 age.setAccessible(true);//暴力反射/*打印teacher1对象中age的值*/ System.out.println(age.get(teacher1)); //40 四、Constructor类​ Constructor类中的常用方法 ​ （1）newInstance（Object… initargs） ​ 根据构造器构造对象，参数为构造器所需参数 ​ 示例程序： 123456789101112131415 /*获取无参构造函数*/Constructor constructor = class5.getConstructor();/*用无参构造函数创建Teacher对象*/ Teacher teacher2 = (Teacher) constructor.newInstance();/*获取双参构造函数*/ Constructor constructor1 = class5.getConstructor(String.class,Integer.class); /*用双参构造函数创建Teacher对象*/Teacher teacher3 = (Teacher) constructor1.newInstance(\"李老师\",40);/*打印结果*/ System.out.println(teacher2); System.out.println(teacher3);/*Teacher&#123;name='null', age=null&#125; Teacher&#123;name='李老师', age=40&#125;*/ 五、Method类​ Method类中的常用方法 ​ （1）invoke(Object obj,Object… initargs) ​ 执行被获取的方法，参数为执行该方法的对象，以及方法所需要的参数 ​ 示例程序： 12345678910111213141516/*获取无参构造函数*/Constructor constructor = class5.getConstructor();/*用无参构造函数创建Teacher对象*/ Teacher teacher2 = (Teacher) constructor.newInstance();/*获取双参构造函数*/ Constructor constructor1 = class5.getConstructor(String.class,Integer.class); /*用双参构造函数创建Teacher对象*/Teacher teacher3 = (Teacher) constructor1.newInstance(\"李老师\",40);/*调用无参teach方法*/method1.invoke(teacher3);/*调用有参teach方法*/method2.invoke(teacher3,\"五年级一班\");/* 上课中 在五年级一班上课中*/ ​ 以上teach方法实现如下： 123456public void teach()&#123; System.out.println(\"上课中\"); &#125; public void teach(String classroom)&#123; System.out.println(\"在\" + classroom + \"上课中\"); &#125;","categories":[],"tags":[]},{"title":"Spring学习笔记（四）","slug":"Spring学习笔记（四）","date":"2020-02-18T12:18:27.447Z","updated":"2020-02-18T12:17:12.643Z","comments":true,"path":"2020/02/18/Spring学习笔记（四）/","link":"","permalink":"http://yoursite.com/2020/02/18/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"Spring学习笔记（四）​ 今天的主要学习内容是通过aop实现Spring的自动事务配置。但Spring的自动事务配置需要使用JdbcTemplate进行持久层编写来配合使用。所以今日的学习内容主要分为了解JdbcTemplated的使用与掌握Spring自动事务配置 一、JdbdTemplate​ *1.概述 * ​ JdbcTemplate是Spring框架提供的一个对象，是对原始Jdbc API的一层简单封装。 ​ JdbcTemplate对象类存在于spring-jdb-5.0.2.RELEASE.jar中,另外Spring的事务控制存在于spring- tx-5.0.2.RELEASE.jar中 ​ 2.使用方法 ​ (1)在持久层中 使用JdbcTemplate对象进行数据的增删改查： 1234567891011121314151617/** * 查找一个 * @param id * @return */ public Account findById(Integer id) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ?\",new AccountRowMapper(),id); return list.isEmpty() ? null : list.get(0) ; &#125; /** * 保存账户 * @param account */ public void save(Account account) &#123; jdbcTemplate.update(\"update account set money = ? where id = ?\",account.getMoney(),account.getId()); &#125; ​ 此处仅以增与查为例。jdbcTemplate的方法里需要提供的参数：sql语句，RowMapper对象，sql语句中的未知参数 ​ 其中RowMapper是一个接口，因此我们要自己实现一个AccountRowMapper，作为参数传入findById方法。RowMapper的主要作用是：用于指定数据库表属性与被封装对象属性对应关系，类似于MyBatis中的resultMap ​ (2)定义一个AccountRowMapper类，并编写mapRow方法 12345678910class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet resultSet, int i) throws SQLException &#123; Account account = new Account(); account.setName(resultSet.getString(\"name\")); account.setMoney(resultSet.getDouble(\"money\")); account.setId(resultSet.getInt(\"id\")); return account ; &#125; ​ (3)配置jdbc的bean对象，并注入数据源。 12345&lt;!-- 配置JdbcTemplate对象 --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!-- 注入数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; ​ (4)配置数据源（数据源目前有三种选择：C3P0，DBCP，spring内置数据源，此处使用第三种） 12345678&lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 注入数据库连接属性 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimeZone=UTC\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;/bean&gt; ​ (5)配置成功，测试即可 二、Spring的事务控制​ 在上一节的学习中，我们自己手动编写了事务管理器，并用配置aop的方式构建了新的切面，给业务层方法添加了事务管理。但是，在强大的Spring中，我们甚至不需要自己手写这些事务管理器，而可以使用Spring内置的事务管理器。我们要做的就是完成配置，即可实现事务控制。同样，Spring的事务控制可以通过xml与注解两种配置方式实现： ​ 1.基于xml的事务控制 ​ （1） 配置事务管理器 12345&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; ​ (2)配置事务及其属性 12345678&lt;!-- 配置事务 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 配置事务属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; ​ (3)配置AOP切面表达式 1234567&lt;!-- 配置AOP --&gt;&lt;aop:config&gt; &lt;!-- 配置切面表达式--&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.itheima.service.Impl.*.*(..))\"/&gt; &lt;!-- 配置事务的通知和切入点表达式的关系 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; ​ (4)配置事务通知和切入点表达式的关系 1234567&lt;!-- 配置AOP --&gt;&lt;aop:config&gt; &lt;!-- 配置切面表达式--&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.itheima.service.Impl.*.*(..))\"/&gt; &lt;!-- 配置事务的通知和切入点表达式的关系 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; ​ 2.基于注解的事务配置 ​ (1)配置事务管理器（同上） ​ (2)开启Spring对注解事务的支持 12&lt;!-- 开启Spring对注解事务的支持 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt; ​ (3)在被增强方法的类上添加@Transactional注解 1234@Service(\"accountService\")@Transactional(propagation = Propagation.REQUIRED,readOnly = false)public class AccountServiceImpl implements IAccountService &#123;&#125; ​ (4)查询方法事务属性独特，可特定配置。(直接将注解加在方法前即可) 1234@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)public Account findById(Integer id) &#123; return accountDao.findById(id);&#125; 三、Spring事务控制细节补充​ 1.事务属性 ​ Spring的自动事务控制，可以配置其相关属性，主要分为以下六点 read-only：是否是只读事务。默认 false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回 滚。没有默认值，任何异常都回滚。 ​ 2.持久层支持 ​ 笔者在学习初期，使用了dbutils实现持久层，但是在测试转账方法时，无法实现出现异常时的事务回滚,即事务配置失败。在改用jdbcTemplate之后，成功实现。 ​ 经验：Spring的自动事务控制需要配合jdbcTemplate，而不能使用dbutils。至于其他持久层实现如MyBatis能否成功配合Spring实现事务控制，作为小白的笔者尚不明确，盲猜一个“可以”。在日后的学习中，笔者一定会逐渐去接触Spring源码，有朝一日，定会以解决这个问题。","categories":[],"tags":[]},{"title":"IDEA报错： class com.sun.proxy.$Proxy11 cannot be cast to ’XXXXX‘","slug":"IDEA报错： class com.sun.proxy.$Proxy11 cannot be cast to ’XXXXX‘","date":"2020-02-18T00:38:51.978Z","updated":"2020-02-18T00:40:33.493Z","comments":true,"path":"2020/02/18/IDEA报错： class com.sun.proxy.$Proxy11 cannot be cast to ’XXXXX‘/","link":"","permalink":"http://yoursite.com/2020/02/18/IDEA%E6%8A%A5%E9%94%99%EF%BC%9A%20class%20com.sun.proxy.$Proxy11%20cannot%20be%20cast%20to%20%E2%80%99XXXXX%E2%80%98/","excerpt":"","text":"IDEA报错： class com.sun.proxy.$Proxy11 cannot be cast to ’XXXXX‘​ 今天在学习Spring事务配置的过程中，发生了如上错误。原程序如下： 12345678public void testFindById()&#123; //获取ApplicationConext对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //获取AccountServiceImpl对象 IAccountService as = (AccountServiceImpl) ac.getBean(\"accountService\"); //执行方法 System.out.println(as.findById(2)); &#125; ​ 该测试类方法测试了根据id查找account对象的功能。在没有配置事务的时候，程序可以正常执行，但是在根据AOP配置了事务之后，出现了题示问题。 ​ 问题分析：由于Spring AOP的动态代理机制如下：对于没有实现任何接口的类，采用CGLIB方法；对于实现了接口的对象，默认使用JDK动态创建代理对象。而AccountServiceImpl实现了IAccountService接口，所以在获取bean对象并进行强制转换时，要转换成父类IAccountService。 ​ 解决方法：所以将上述代码中小括号中的AccountServiceImpl改成IAccountService即可. 12345678public void testFindById()&#123; //获取ApplicationConext对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //获取AccountServiceImpl对象 IAccountService as = (IAccountService) ac.getBean(\"accountService\"); //执行方法 System.out.println(as.findById(2)); &#125;","categories":[],"tags":[]},{"title":"Spring学习笔记（三）","slug":"Spring学习笔记（三）","date":"2020-02-14T11:53:06.553Z","updated":"2020-02-14T11:52:11.176Z","comments":true,"path":"2020/02/14/Spring学习笔记（三）/","link":"","permalink":"http://yoursite.com/2020/02/14/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"Spring学习笔记（三）​ 在前两个学习笔记中，我们掌握了Spring的第一个核心IOC，现在我们开始学习Spring的另一个核心，AOP 一、AOP简介​ 1.概述： ​ AOP为Aspect Oriented Programming的缩写，即面向切面编程。AOP是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。 ​ 简单的说，AOP可以将我们重复的代码抽取出来，在需要执行时，采用动态代理的技术，在不修改源码的基础上，对原有方法进行增强 ​ 2.优势： ​ 减少重复代码 ​ 提高开发效率 ​ 方便维护 二、AOP引入：​ 1.问题抛出： ​ 在Spring学习笔记（二）中，我们实现了对Account对象的增删改查的持久层与业务层操作，并通过IOC配置，降低了程序的耦合。现我们增加一个transfer（即转账）操作，实现账户A向账户B的转账： 1234567891011121314public void transfer(Integer giveAccountId, Integer recieveAccountId, Double money)&#123; //1.获取转出账户 Account giveAccount = accountDao.findById(giveAccountId); //2.获取转入账户 Account recieveAccount = accountDao.findById(recieveAccountId); //3.转出账户减钱 giveAccount.setMoney(giveAccount.getMoney()-money); //4/转入账户价钱 recieveAccount.setMoney(recieveAccount.getMoney()+money); //5.更新转出账户 accountDao.update(giveAccount); //6.更新转入账户 accountDao.update(recieveAccount); &#125; ​ 如此简单的实现，很容易出现不同步的问题：如果在第五步–更新转出账户操作之后,程序出现了异常（例如在第五步后添加一句 int a = 1/0;)，那么第六步将不会成功执行，就会产生一个可怕的后果：转出账户的钱减少了，但是转入账户的前没有增加。 ​ 2.问题分析： ​ 为了解决这个问题我们需要加入事务控制，使得这些操作由一个连接来操作，而且使它们一起成功或者一起失败。 ​ 为此，我们编写了connectionUtils与TransactionManager类来进行事务控制。 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.utils;import javax.sql.DataSource;import java.sql.Connection;public class ConnectionUtils &#123; private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;(); private DataSource dataSource ; public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; public Connection getThreadConnection()&#123; //1.先从ThreadLocal上获取 Connection conn = tl.get(); //2.判断当前线程上是否有连接 try&#123; if(conn==null)&#123; //3.从数据源中获取一个连接，并且存入ThreadLocal中 conn = dataSource.getConnection(); tl.set(conn); &#125; //4.返回当前线程上的连接 return conn ; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125; &#125; /** * 把连接和线程解绑 */ public void removeConnection()&#123; tl.remove(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.itheima.utils;/** * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接 */public class TransactionManager &#123; private ConnectionUtils connectionUtils ; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** * 开启事务 */ public void beginTransaction()&#123; try&#123; connectionUtils.getThreadConnection().setAutoCommit(false); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 提交事务 */ public void commit()&#123; try&#123; connectionUtils.getThreadConnection().commit(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 回滚事务 */ public void rollback()&#123; try&#123; connectionUtils.getThreadConnection().rollback(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 释放连接 */ public void release()&#123; try&#123; connectionUtils.getThreadConnection().close(); //还回连接池中 connectionUtils.removeConnection(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; ​ 接下来就需要整合我们的转账操作与事务控制，使得能够保证转入与转出操作能够同步执行。这时候就会面临一个关键的问题： ​ 如果直接将这些事务控制加到业务层接口实现类中，这会导致大量的代码重复，提升程序耦合性，而且需要修改源码。这样的作法是我们极不提倡的 ​ 于是我们可以通过动态代理的方式，来解决上述问题。自己编写动态代理类，对于大神来说很轻松，但是对于小白来说，甚至会无从下手。而Spring技术可以通过AOP配置的方式，来帮我们自动实现动态代理，这就极大的方便了对原方法增强的操作。 三、AOP细节​ 1.AOP相关术语 ​ （1）Joinpoint（连接点）：连接点是那些被拦截的点。在Spring中，这些点值的是被增强类的所有方法。 ​ （2）Pointcut（切入点）：切入点是指我们要对哪些JoinPoint进行拦截的定义。即所有被增强的方法。注意：所有切入点都是连接点，但连接点不一定是切入点。 ​ （3）Target（目标对象）：被代理对象 ​ （4）Proxy（代理）：一个类被织入增强后，产生的代理对象 ​ （5）Weaving（织入）：把增强应用到目标对象来创建新的代理对象的过程。spring使用动态代理植入。 ​ （6）Advice（通知/增强）：通知时拦截到连接点之后需要增加的代码。通知有五种类型：前置通知、后置通知、异常通知、最终通知、环绕通知 ​ （7）Introduction（引介）：引介是一种特殊的通知，在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field。 ​ （8）Aspect（切面）：切入点与通知的结合 ​ 2.代理的选择 ​ 在Spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式 四、基于XML的AOP配置​ 1.导入jar包： ​ mysql、spring-framework、spring-test、commons-dbutils、c3p0、junit，aspectjweaver ​ 2.在bean.xml文件中导入约束 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; ​ 3.配置通知bean对象: 12345&lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"TxManager\" class=\"com.itheima.utils.TransactionManager\"&gt; &lt;!-- 注入connectionUtils--&gt; &lt;property name=\"connectionUtils\" ref=\"connectionUtils\"&gt;&lt;/property&gt; &lt;/bean&gt; ​ 4.配置切面： 1234567891011&lt;!-- 配置AOP--&gt; &lt;aop:config&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id=\"TxManager\" ref=\"TxManager\"&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* *..AccountServiceImpl.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;aop:before method=\"beginTransaction\" pointcut-ref=\"pt1\"&gt;&lt;/aop:before&gt; &lt;aop:after-returning method=\"commit\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=\"rollback\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-throwing&gt; &lt;aop:after method=\"release\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; ​ &#60;aop:config&#62;标签用于标识开始AOP配置 ​ &#60;aop:aspect&#62;标签用于标识开始AOP切面配置 ​ &#60;aop:pointcut&#62;标签用于配置切入点表达式，id属性指定该切入点表达式的标识符，expression指定被配置的切入点表达式 ​ &#60;aop:before&#62;标签用于配置前置通知，method属性指定作为前置通知的方法，pointcut-ref属性中填写切入点表达式，指定被增强的方法 ​ &lt;aop:after-returning&#62;标签用于配置后置通知，作用同上 ​ &lt;aop:after-throwing&#62;标签用于配置异常通知，作用同上 ​ &lt;aop:after&#62;标签用于配置最终通知，作用同上 ​ 5.配置完成，测试结果 12345678/** * 测试转账操作 */ @Test public void testTransfer()&#123; //执行转账操作 as.transfer(2,1,450.0); &#125; ​ 该测试类调用转账操作，我们在更新转出账户之后添加了异常语句（int a =1/0;），执行。 ​ 执行结果失败，但是事务回滚成功，转出账户的money没有减少。成功！ 五、基于注解的AOP配置​ 1.导入jar包 ​ 同4.1 ​ 2.在bean.xml中导入约束 ​ 同4.2 ​ 3.在通知类上添加@Aspect注解 123@Aspectpublic class TransactionManager &#123;&#125; ​ 4.在相应的通知前加上相应的注解(@Before @AfterReturning@AfterThrowing@After) 1234567891011/** * 开启事务 */@Before(\"execution(* *..AccountServiceImpl(..))\") public void beginTransaction()&#123; try&#123; connectionUtils.getThreadConnection().setAutoCommit(false); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; ​ 注解的小括号中写好切入点表达式 ​ 5.在Sprig配置文件中开启Spring对注解AOP的支持（一句配置即可） 1&lt;aop:aspectj-autoproxy/&gt; 六、环绕通知的配置​ 环绕通知是一种很特殊的通知，通过配置环绕通知甚至可以实现所有其他四种通知的配置。 ​ 1.bean.xml中配置环绕通知 1234567&lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* com.itheima.service.impl.*.*(..))\"id=\"pt1\"/&gt; &lt;aop:aspect id=\"txAdvice\" ref=\"txManager\"&gt; &lt;!-- 配置环绕通知 --&gt; &lt;aop:around method=\"transactionAround\" pointcut-ref=\"pt1\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; ​ 2.编写transactionAround方法 123456789101112131415161718192021222324252627/** * 环绕通知 * @param pjp * spring 框架为我们提供了一个接口：ProceedingJoinPoint，它可以作为环绕通知的方法参数。* 在环绕通知执行时，spring 框架会为我们提供该接口的实现类对象，我们直接使用就行。* @return*/public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue; &#125; ​ 若是采用注解配置的方式，则整合以上两步，在transactionAround方法上添加注解@Around即可 1234567891011121314151617181920212223242526/** * 环绕通知 * @param pjp * @return */@Around(\"execution(* com.itheima.service.impl.*.*(..))\")public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue; &#125;","categories":[],"tags":[]},{"title":"Spring学习笔记（二）","slug":"Spring学习笔记（二）","date":"2020-02-11T04:38:32.889Z","updated":"2020-02-11T04:37:56.116Z","comments":true,"path":"2020/02/11/Spring学习笔记（二）/","link":"","permalink":"http://yoursite.com/2020/02/11/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"Spring学习笔记（二）​ 今日学习的主要内容，是基于注解的IOC配置以及Spring整合JUnit的测试操作。注解开发分为两个部分： 常用注解与新注解。常用注解主要用于配置自己编写的类，而新注解用于配置引用的无法修改的类。常用注解的使用可以明显地简化开发，但新注解常常使步骤更加繁琐。所以，我们在开发中应保持一下原则：自己编写的类使用常用注解，引用的类采用xml配置。 ​ ​ 在讲解常用注解之前，首先要注意环境配置。 ​ 在xml配置的基础上，只需要1)更改约束，2)添加一句xml语句指定创建IOC容器要扫描的包即可： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 一、常用注解​ Spring的常用注解分为四类：用于创建对象的（4），用于注入数据的（4），用于控制作用范围的（1），与生命周期相关的（2）。 1、用于创建对象的​ 相当于 ​ 1） @Component： ​ 作用：把对象交给Spring来管理，相当于在xml中配bean ​ 位置：在对象类的上方 ​ 属性：value属性：指定bean的id。若不指定value，则bean的默认id是当前类的类名（首字母小写） ​ 示例：在本例中，备注解的类AccountDaoImpl，在IOC容器中被创建，且id为accountDao 123@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123;&#125; ​ 2）@Controller @Service @Repository ​ 这三个注解的作用、位置、属性与@Component完全相同，只不过@Controller常用在控制层类前，@Service常用在业务层类前，@Repository常用在持久层类前 2、用于注入数据的​ 相当于或 ​ 1） @Autowired ​ 作用:自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他bean类型。当IOC容器中有多个bean类型与之匹配时，使用要注入的对象变量名称作为bean的id，在Spring容器中查找key，找到相同也可成功注入。找不到则报错 ​ 示例： 1234public class AccountDaoImpl implements IAccountDao &#123; @Autowired private AccountDaoImpl accountDao;&#125; ​ 2）@Qualifier ​ 作用：在自动按照类型的基础上，在按照Bean的id注入。它在给字段注入时不能独立使用，必须和@Autowired一起使用；但是给方法参数注入时，可以单独使用。 ​ （相当于Autowired是狙击枪，Qualifier是瞄准镜，可以根据id更好地定位，以解决IOC容器中有多个bean类型与被注解bena对象类型匹配的问题） ​ 属性：value：指定bean的id ​ 示例： 12345public class AccountDaoImpl implements IAccountDao &#123; @Autowired @Qualifier(\"accountDao\") private AccountDaoImpl accountDao;&#125; ​ 3)@Resource ​ 作用：直接按照Bean的id注入。相当于Autowired与Qualified的整合，也只能注入bean对象 ​ 属性：name：指定bean的id 1234public class AccountDaoImpl implements IAccountDao &#123; @Resource(name=\"accountDao\") private AccountDaoImpl accountDao;&#125; ​ 4)@Value ​ 作用：注入基本类型的数据和String类型的数据 ​ 属性：value：用于指定值 ​ 示例： 123456public class AccountDaoImpl implements IAccountDao &#123; @Value(value=\"12.0\") private Double money; @Value(\"xioawang\") private String name;&#125; 3、用于改变作用范围的​ 相当于 ​ 1）@Scope ​ 作用：指定bean的作用范围 ​ 属性：value：指定范围的值： ​ 取值：singleton protoType request session globalsession 4、与生命周期相关的（了解）​ 相当于 ​ 1）@PostConstruct ​ 作用：用于定义初始化方法 ​ 2）@PreDestroy ​ 作用： 用于指定销毁方法 二、新注解​ 1.@Component ​ 作用：用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext（有@Component注解的类.class) ​ 属性：value：用于指定配置类的字节码 ​ 示例： 123@Configuration public class SpringConfiguration &#123;&#125; ​ 2.@ComponentScan ​ 作用：用于指定Spring在创建初始化IOC容器时要扫描的包。作用和在xml配置中的： &lt;context:component-scan base-package=”com.itheima”/&gt;是一样的 ​ 属性：backPackages/value:用于指定要扫描的包。 ​ 示例： 1234@Configuration @ComponentScan(\"com.itheima\") public class SpringConfiguration &#123;&#125; ​ 3.@Bean ​ 作用：该注解只能卸方法上，表明使用此方法创建一个对象，并存入Spring容器。 ​ 属性：name：给当前@Bean注解方法创建的对象指定一个名称（即bean的id） ​ 示例： 12345678910111213141516171819public class JdbcConfig &#123; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name=\"dataSource\") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setUser(\"root\"); ds.setPassword(\"1234\"); ds.setDriverClass(\"com.mysql.jdbc.Driver\"); ds.setJdbcUrl(\"jdbc:mysql:///spring_day02\"); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 创建一个 DBAssit，并且也存入 spring 容器中 * @param dataSource * @return */ @Bean(name=\"dbAssit\") public DBAssit createDBAssit(DataSource dataSource) &#123; return new DBAssit(dataSourc e); &#125; &#125; ​ 4.@Import ​ 作用: 用于在主配置文件中，引入从配置文件。从配置文件可以不写@Configuration注解，但是写了也不报错。 ​ 属性：value[]：用于指定其他配置类的字节码 ​ 示例： 123456789@Configuration @ComponentScan(basePackages = \"com.itheima.spring\") @Import(&#123; JdbcConfig.class&#125;) public class SpringConfiguration &#123; &#125;@Configurationpublic class JdbcConfig&#123;&#125; ​ 5.@PropertySource ​ 作用：用于加载properties文件中的配置。例如我们配置数据源时，可以把数据库的连接信息写在properties配置文件中，就可以使用此注解指定properties配置文件的位置。 ​ 属性：value[]:用于指定properties文件位置。如果是类路径下，需要写上classPath: ​ 示例： 有一个jdbConfig.properties文件,指定了数据库连接的信息： 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/test?serverTimeZone=UTCjdbc.username=rootjdbc.password=123456 且有一个数据库信息配置类通过自动注入的方式注入这些信息； 1234567891011public class jdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver ; @Value(\"$&#123;jdbc.url&#125;\") private String url ; @Value(\"$&#123;jdbc.username&#125;\") private String username ; @Value(\"$&#123;jdbc.password&#125;\") private String password ;&#125; 但要想java类能够找到这些信息，必须有一个注解来告诉它，去哪儿可以找到这些el表达式指定的值。 即用propertySource注解来指定properties文件 123456@Configuration@ComponentScan(\"com.itheima\")@Import(jdbcConfig.class)@PropertySource(\"jdbc.properties\")public class SpringConfiguration &#123;&#125; 三、Spring与Junit的整合​ 问题 ​ 在测试类中，每个测试方法都有以下两行代码： 123ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");IAccountService as = ac.getBean(\"accountService\",IAccountService.class); ​ 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 ​ 解决方法 ​ 但是通过Spring框架与JUnit的整合，它可以提供一个运行器，可以读取配置文件（或注解）来创建容器，我们只需要告诉它配置文件在哪儿即可。 ​ 配置步骤： ​ 1.拷贝整个JUnit的必备jar包到lib目录。（IDEA编写pom.xml可自动导包） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; ​ 2.使用@RunWith注解替换原有运行器 123@RunWith(SpringJUnit4ClassRunner.class) public class AccountServiceTest &#123;&#125; ​ 3.使用@ContextConfiguration指定Spring配置文件的位置 1234@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= &#123;\"classpath:bean.xml\"&#125;) public class AccountServiceTest &#123;&#125; ​ 4.使用@Autowired给测试类的变量注入数据 12345@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;\"classpath:bean.xml\"&#125;)public class AccountServiceTest &#123; @Autowired private IAccountService as ;&#125;","categories":[],"tags":[]},{"title":"Spring学习笔记（一）","slug":"Spring学习笔记（一）","date":"2020-02-09T02:31:07.892Z","updated":"2020-02-09T02:30:27.145Z","comments":true,"path":"2020/02/09/Spring学习笔记（一）/","link":"","permalink":"http://yoursite.com/2020/02/09/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Spring学习笔记（一）​ MyBatis的学习已经告一段落了，持久层往上就到了服务层。服务层的技术便是我们顶顶大名的spring。 一、Spring概述​ Spring是一款javaEE轻量级开源框架，以IOC（反转控制）和AOP（面向切面编程）为内核，提供了SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架，和类库，逐渐成为使用最多的JavaEE企业应用开源框架。 二、Spring的优势​ 1.方便解耦，简化开发 ​ 2.AOP编程的支持 ​ 3.声明式事务的支持 ​ 4.方便程序的测试 ​ 5.方便集成各种优秀框架 ​ 6.降低JavaEE的使用难度 ​ 7.Spring源码是经典的学习案例 三、程序耦合​ 在讲解Spring的一大核心IOC之前，我们首先要弄明白什么是程序的耦合。 ​ 在这里引入一小段耦合的概念，看不懂一笑而过即可。 在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计 应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。 ​ 用通俗的话来说，耦合就是程序尤其是对象之间的关联程度。关联程度越高，我们修改代码时，需要修改的地方就越多。这样既会导致维护成本提高，也会致使出错的概率提升。所以我们要尽量减少程序间的关联程度，即耦合度。 ​ 耦合有以下分类： 1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另 一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大 量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进 行适当的动作，这种耦合被称为控制耦合。 5） 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。 6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另 一些模块的输入数据。 7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 ​ ​ 总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在编写程序的过程中，我们应采取一下原则：如果模块间必须存在耦合，那么尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免内容耦合 四、程序解耦举例​ 我们可以将解耦理解成一句话，即：做到程序编译器不报错，运行期才报错 ​ 以JDBC基本操作为例，我们在注册驱动时可以采用以下的写法： 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); ​ 由于我们采用了new关键字，一旦我们将mysql驱动的jar包删除，这条语句将在编译器就会报错，这体现出JDBC与Driver类的耦合度过高。 ​ 要想降低两者之间的耦合度，可以用反射的机制来注册驱动： 1Class.forName(\"com.mysql.jdbc.Driver\");//此处只是一个字符串 ​ 采用这种写法，即使删除jar包，编译器也不会报错，这便实现了解耦。（当然程序是无法运行的，在运行期必然会报错。） ​ 实际上一种更常见的解耦方式就是采用工厂模式来实现控制反转（IOC） 五、IOC–控制反转​ 概念： 控制反转把创建对象的权利交给框架，是框架的重要特征，并非面向对象编程的专用术语。它包括依赖注入和依赖查找 ​ 作用： 削减计算机·程序的耦合，降低程序间的以来关系 ​ 分析： ​ 原来我们获取对象时，采用new的方式，是主动去找 ​ 现在我们获取对象时，是由工厂创建或查找得到的，是被动获得。 ​ 这种控制权交给工厂的形式就叫做控制反转（IOC） 六、Spring中的IOC​ Spring框架一大精妙之处就在于，能够帮助实现控制反转，通过配置bean对象，spring可以自动生成该对象的工厂，并且提供服务。这不仅有利于降低程序间的耦合，还大大提高了开发效率。 ​ 入门案例： ​ 通过spring中xml配bean的方式，实现dao与service对象的创建： ​ 1.导入spring依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; ​ 2.编写service与dao层的接口与实现类（省略） ​ 3.配置bean.xml文件 12345678910&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 把对象的创建交给spring来管理 --&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.Impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.itheima.dao.Impl.AccountDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; ​ 4.创建使用bean对象 12345678910public static void main(String[] args) &#123; //获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据id获取bean对象 IAccountService as = (IAccountService) ac.getBean(\"accountService\"); IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class); System.out.println(as); System.out.println(adao); &#125; ​ 5.（成功）测试打印结果 12com.itheima.service.Impl.AccountServiceImpl@5ea434c8com.itheima.dao.Impl.AccountDaoImpl@3bbc39f8 ​ 值得注意的·是，根据id获取bean对象时，有两种方式进行类型转换： ​ 1.强制类型转换 ​ 2.传入转后类型的字节码作为参数 六、SpringIOC的细节与bean标签​ 1.beanFactory与ApplicationContext的联系与区别： ​ BeanFactory是Spring的顶层接口，ApplicationContext是BeanFactroy的底层接口 ​ ApplicationContext接口的实现类： ​ （1）ClassPathXmlApplicationContext: ​ 从类的根路径下加载配置文件 （推荐使用） ​ （2）FileSystemXmlApplicationContext： ​ 从磁盘的路径下加载配置文件，配置文件可以在磁盘的任意位置 ​ （3）AnnotationConfigApplicationContext： ​ 使用注解配置容器对象时，需要此类来创建spring容器。它用来读取注解 ​ BeanFactroy与ApplicationConext的创建对象的时间不同： ​ （1）BeanFactory只有当对象被使用的时候，才会创建对象（延迟加载） ​ （2） ApplicationConext只要加载配置文件，就会创建对象（立即加载） ​ 2.bean标签 ​ 作用： ​ 用于配置对象，以便Spring创建。 ​ 默认情况下它调用对象类中的无参构造函数。如果没有无参构造函数则创建失败 ​ 属性： ​ （1）id：给对象在容器中提供唯一标识。用于获取对象 ​ （2）class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数 ​ （3）scope：指定对象的作为范围： ​ a) singleton: 默认值，单例的 ​ b) prototype: 多例的 ​ c) request: WEB项目中，Spring创建一个Bean对象，将对象存到request域中 ​ d）session：在WEB项目中，Spring创建一个Bean对象，将对象存到session域中 ​ e）globalSession：WEB项目中，运行在Portlet环境中，如果没有Protlet环境， globalSession相当于session ​ (4) init-method:指定类中的初始化方法名称 ​ (5) destroy-method:指定类中的销毁方法名称 ​ bean对象的作用范围与生命周期： ​ 单例对象：scope=”singleton”: ​ 一个应用只有一个对象的实例。作用范围即整个应用 ​ 生命周期： ​ 对象出生：当应用加载，创建容器时，对象就被创建了 ​ 对象活着：只要容器在，对象一直活着 ​ 对象死亡：当应用卸载，销毁容器时，对象就被销毁了 ​ 多例对象：scope=”protoType”: ​ 每次对象访问的时候，都会重新创建对象实例 ​ 生命周期： ​ 对象出生：当使用对象时，新的对象被创建 ​ 对象活着：只要对象在使用中，就一直活着 ​ 对象死亡：当对象长时间不用时，被java垃圾回收器回收了 ​ 实例化bean对象的三种方式： ​ （1）使用默认无参构造函数： 123&lt;!--在默认情况下：它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"/&gt; ​ (2)spring管理工厂–使用实例工厂的方法创建对象(当我们要创建jar包中的类时，这个类又没有无参构造函数，常常使用这种方式) 12345678910&lt;!-- 此种方式是：先把工厂的创建交给 spring 来管理。然后在使用工厂的 bean 来调用里面的方法 factory-bean 属性：用于指定实例工厂 bean 的 id。factory-method 属性：用于指定实例工厂中创建对象的方法。--&gt;&lt;bean id=\"instancFactory\" class=\"com.itheima.factory.InstanceFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"accountService\" factory-bean=\"instancFactory\" factory-method=\"createAccountService\"&gt;&lt;/bean&gt; (3) spring静态管理工厂--使用静态工厂的方法创建对象: 123456789&lt;!-- 此种方式是: 使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器 id 属性：指定 bean 的 id，用于从容器中获取 class 属性：指定静态工厂的全限定类名 factory-method 属性：指定生产对象的静态方法--&gt;&lt;bean id=\"accountService\" class=\"com.itheima.factory.StaticFactory\" factory-method=\"createAccountService\"&gt;&lt;/bean&gt; 七、Spring的依赖注入​ 依赖注入：Dependency Injection。它是Spring框架核心IOC的具体体现 ​ 我们在程序编写时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低耦合度，但不会消除耦合。例如我们的业务层仍会调用持久层的方法。 ​ 那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring去维护了/ ​ 简答的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 ​ Spring依赖注入的三种规范方式： ​ （1）构造函数注入： ​ 顾名思义，即通过调用使用类中的构造函数，给成员变量赋值。 ​ 例如某个AccountService类如下： 12345678public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125;&#125; ​ 注入方式： 123456789101112131415161718192021&lt;!-- 使用构造函数的方式，给 service 中的属性传值 要求： 类中需要提供一个对应参数列表的构造函数。 涉及的标签： constructor-arg 属性： index:指定参数在构造函数参数列表的索引位置 type:指定参数在构造函数中的数据类型 name:指定参数在构造函数中的名称 用这个找给谁赋值 =======上面三个都是找给谁赋值，下面两个指的是赋什么值的============== value:它能赋的值是基本数据类型和 String 类型 ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.Impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Data\"&gt;&lt;/bean&gt; ​ (2)set方法注入： ​ 顾名思义，就是在类中提供需要注入成员的set方法。 ​ 例如某个AccountService类如下： 1234567891011121314public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125;&#125; ​ 注入方式如下； 123456789101112131415&lt;!-- 通过配置文件给 bean 中的属性传值： 使用 set 方法的方式 涉及的标签： property 属性： name：找的是类中 set 方法后面的部分 ref：给属性赋值是其他 bean 类型的 value：给属性赋值是基本数据类型和 string 类型的 实际开发中，此种方式用的较多。--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"name\" value=\"test\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"21\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; ​ （3）使用p名称空间注入数据（本质还是调用set方法） ​ 此种方式是通过在xml种导入p名称空间，使用p：propertyName来注入数据，它的本质仍是调用类中的set方法实现注入功能。 ​ AccountService类同上 ​ 注入方式： 123456789&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl4\" p:name=\"test\" p:age=\"21\" p:birthday-ref=\"now\"/&gt;&lt;/beans&gt; ​ (4)注入集合属性 ​ 顾名思义，就是给类种的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List，Set，Map，Properties。 ​ 例如某AccountService类如下： 12345678910111213141516171819202122public class AccountServiceImpl implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125;&#125; ​ 注入方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051!-- 注入集合数据 List 结构的： array,list,set Map 结构的 map,entry,props,prop--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt; &lt;!-- 给数组注入数据 --&gt; &lt;property name=\"myStrs\"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入 list 集合数据 --&gt; &lt;property name=\"myList\"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 注入 set 集合数据 --&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入 Map 数据 --&gt; &lt;property name=\"myMap\"&gt; &lt;props&gt; &lt;prop key=\"testA\"&gt;aaa&lt;/prop&gt; &lt;prop key=\"testB\"&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 注入 properties 数据 --&gt; property name=\"myProps\"&gt; &lt;map&gt; &lt;!-- 方式1 --&gt; &lt;entry key=\"testA\" value=\"aaa\"&gt;&lt;/entry&gt; &lt;!-- 方式2 --&gt; &lt;entry key=\"testB\"&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;","categories":[],"tags":[]},{"title":"MyBatis学习笔记（四）","slug":"MyBatis学习笔记（四）","date":"2020-02-05T00:59:24.771Z","updated":"2020-02-04T08:45:08.756Z","comments":true,"path":"2020/02/05/MyBatis学习笔记（四）/","link":"","permalink":"http://yoursite.com/2020/02/05/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记（四）一、MyBatis的延迟加载​ 问题： ​ 在一对多中，我们有一个用户，它有100个账户， ​ 在查询用户时，要不要吧关联的账户查出来？ ​ 在查询账户是，要不要把关联的用户查出来？ ​ 答案： ​ 在查询用户时，用户下的账户信息应随用随查（延迟加载） ​ 在查询账户时，账户的所属用户应立即查出来（立即加载） ​ 延迟加载： ​ 在使用数据时才发起查询，不用的时候不查询，又称按需加载（懒加载） ​ 立即加载： ​ 不管用不用，只要调用方法，马上发起查询 ​ 一对多，多对多采用延迟加载 ​ 一对一，多对一采用立即加载 二、MyBatis延迟加载的实现举例： ​ 使用User与Account模型分别实现一对一与一对多的延迟加载 核心思想： ​ 将sql语句中的多表关联查询改成单表查询，并在需要访问关联数据时，再通过按需查询的方式取出关联数据。 一对一延迟加载实现： ​ 1.在sqlMapConfig.xml配置文件中打开延迟缓存的全局开关 1234&lt;settings&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"&gt;&lt;/setting&gt;&lt;/settings&gt; ​ 1.将account对象中的findAll方法的xml配置文件中的sql语句改成 1select * from account ​ 2.在IAccountDao.xml中的resultMap属性中的association中，我们不再配置id与result元素，而是添加select和colomn属性 1234567&lt;association property=\"user\" column=\"uid\" javaType=\"user\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt;&lt;/association&gt; ——–&gt; 1&lt;association property=\"user\" javaType=\"user\" select=\"com.itheima.dao.IUserDao.findUserById\" colomn=\"uid\" &gt;&lt;/association&gt; ​ 3.保证IUserDao有findUserById方法及其实现即可 一对多延迟加载实现： ​ 1.将User对象中的findAll方法的xml配置文件中的sql语句改成 1select * from user ​ 2.在IUserDao.xml中的resultMap属性中的collection中，我们不再配置id和result元素，而是添加select和colomn属性 12345&lt;collection property=\"accounts\" ofType=\"account\"&gt; &lt;id column=\"id1\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt;&lt;/collection&gt; ————&gt; 1&lt;collection type=\"accounts\" ofType=\"account\" select=\"com.itheima.dao.IAccountDao.findAccountByUid\" colomn=\"id\"&gt;&lt;/collection&gt; ​ 3.保证在IAccountDao中有findAccountByUid方法及其实现 三、MyBatis缓存​ 像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提 高性能。 ​ Mybatis 中缓存分为一级缓存，二级缓存。 一级缓存： ​ 一级缓存是 SqlSession级别的缓存，只要SqlSession 没有 flush或 close，它就存在。 一级缓存的清空 ​ 当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 二级缓存 ​ 二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个 SqlSession可以共用二级缓存，二级缓存是跨 SqlSession 的，但是保存的散装的数据，而不是完整的对象。 二级缓存的开启与关闭： ​ 1.在sqlMapConfig中开启二级缓存 123456&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt;因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false代表不开启二级缓存。 ​ 2.配置相关的Mapper映射文件 1234&lt;mapper namespace=\"com.itheima.dao.IUserDao\"&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt; ​ 3.配置statement上面的userCache属性 1234567!-- 根据 id查询 --&gt;&lt;select id=\"findById\" resultType=\"user\" parameterType=\"int\" useCache=\"true\"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt;将UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement要使用二级缓存，如果不使用二级缓存可以设置为false。 注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 四、MyBatis的注解开发​ 除了通过配置xml文件的方式，MyBatis还支持注解开发。使用注解可以简化开发，提高开发效率，但是当程序体积增大，使用注解相对更加难以维护。 ​ 注意事项： ​ 若要使用注解开发，就不能创建接口对应的xml文件，否则MyBatis将会报错。 ​ 而且注解开发在sqlMapConfig.xml中的Mapper中要配置class属性而不是resource属性。 123&lt;mappers&gt; &lt;mapper rescource=\"com/itheima/dao/IUserDao.xml\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; ———-&gt; 123&lt;mappers&gt; &lt;mapper class=\"com.itheima.dao.IUserDao\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; ​ 或者使用package也可以 123&lt;mappers&gt; &lt;package name=\"com.itheim.dao\"&gt;&lt;/package&gt;&lt;/mappers&gt; ​ 编写实现： ​ 注解开发可以省去接口对应的xml文件，采用在对应接口的方法前使用注解，并在注解括号中加入sql语句的方式来实现方法。 ​ 常用的注解有： @Insert:实现新增 ​ @Update:实现更新 ​ @Delete:实现删除 ​ @Select:实现查询 ​ @Result:实现结果集封装 ​ @Results:可以与@Result 一起使用，封装多个结果集 ​ @ResultMap:实现引用@Results 定义的封装 ​ @One:实现一对一结果集封装 ​ @Many:实现一对多结果集封装 ​ @SelectProvider: 实现动态SQL映射 ​ @CacheNamespace:实现注解二级缓存的使用 ​ 1.注解开发实现CRUD操作示例： ​ 增： 12345/** * 保存用户 */ @Insert(\"insert into user(username,birthday,sex,address)values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)\") void saveUser(User user); ​ 删： 123456/** * 删除用户 * @param id */ @Delete(\"delete from user where id =#&#123;id&#125;\") void deleteUser(Integer id); ​ 改： 123456/** * 更新用户 * @param user */ @Update(\"update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id =#&#123;id&#125;\") void updateUser(User user); ​ 查： 123456789101112131415161718192021/** * 根据id查找 * @param id * @return */ @Select(\"select * from user where id =#&#123;id&#125;\") User findById(Integer id); /** * 根据名称模糊查询 * @param username * @return */ @Select(\"select * from user where username like #&#123;username&#125;\") List&lt;User&gt; findByName(String username); /** * 查询总记录条数 * @return */ @Select(\"select count(*) from user\") Integer totalCount(); ​ 2.注解开发实现多表查询： ​ 多表查询通过注解开发也很容易实现，只需要配好@Results属性中的@Result中的@One或@Many即可。select属性配置从表被查询时会调用的方法，FetchType设置加载方式（延迟查询，立即查询） ​ 一对一： 123456789/** * 查询所有账户 * @return */ @Select(\"select * from account\") @Results(id=\"accountMap\",value=&#123; @Result(property = \"user\",column =\"uid\",one=@One(select=\"com.itheima.dao.IUserDao.findById\",fetchType = FetchType.EAGER)) &#125;) List&lt;Account&gt; fndAll(); ​ 一对多： 12345678910/** * 查询所有用户 * @return */ @Select(\"select * from user\") @Results(id=\"userMap\",value=&#123; @Result(id=true,property = \"id\",column = \"id\"), @Result(property = \"accounts\",column=\"id\",many=@Many(select=\"com.itheima.dao.IAccountDao.findByUid\",fetchType = FetchType.LAZY)) &#125;) public List&lt;User&gt; findAll(); ​ 3.注解开发使用二级缓存： ​ 不论是xml还是注解开发，一级缓存都是自动开启的。但是二级缓存，需要我们手动开启使用 ​ 开启步骤： ​ （1）在sqlMapConfig.xml中开启全局二级缓存开关（自动开启，本步骤可省略） 1234&lt;!-- 配置开启二级缓存--&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; ​ (2) 在要求开启的接口上开启二级缓存开关(写在整体接口前) 1@CacheNamespace(blocking=true) ​ 开启完毕，直接使用即可","categories":[],"tags":[]},{"title":"MyBatis学习笔记（一）","slug":"MyBatis学习笔记（一）","date":"2020-02-02T01:22:23.180Z","updated":"2020-02-02T01:03:08.330Z","comments":true,"path":"2020/02/02/MyBatis学习笔记（一）/","link":"","permalink":"http://yoursite.com/2020/02/02/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记 （一）本系列笔记学习的是黑马程序员推出的ssm系列课程，感谢老师的精彩讲解，在此立贴以示感激。 一、MyBatis概述​ MyBatis是一款优秀的Java持久层框架，它封装了JDBC，使开发者只需要关注Sql语句本身，二不需要花费精力去处理加载驱动，创建连接、创建Statement等繁杂的过程 ​ MyBatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由MyBatis框架执行sql并将结果映射为java对象并返回。 ​ 采用ORM思想解决了实体和数据库映射的问题，对JDBC进行了封装，屏蔽了JDBC API底层访问细节，是我们不用与JDBC API打交道，就可以完成对数据库的持久化操作。 二、环境搭建1.创建maven工程并导入坐标，即在pom.xml中添加依赖（包括mybatis，mysql，log4j，junit)： 2.创建数据库表以及对应的Java实体类3.创建dao接口​ 4.创建MyBatis的主配置文件（SqlMapConfig.xml):​ ​ 5.创建映射配置文件（IUserDao.xml）： 注意事项：​ 1.在MyBatis中，dao常被成为Mapper ​ 2.包与目录的创建方式不同： ​ 例如：com.itheima.IUserDao以packege方式创建是三级目录， ​ 以目录方式创建是一级目录。 ​ 3.MyBatis的映射文件和Dao接口的包结构必须相同。（即IUserDao.xml与IUserDao.java的包结构必须相同） ​ 4.映射配置文件的mapper的namespace属性必须是dao接口的全限定类名 ​ 5.映射配置文件的操作配置id属性必须是dao接口的方法名 三、入门案例### 1.步骤： 2.设计模式：3.过程分析：​ （1）解析主配置文件获取数据库连接： ​ MyBatis据此自动注册驱动，获取连接，创建connection对象​ （2）解析映射配置文件： ​ 获取执行的sql语句，MyBatis据此构造preparedStatement。 ​ （3）执行查询操作： ​ ResultSet rs = preparedStatemnt.executeQuery(); ​ (4) 遍历结果集并封装 ​ List list = new ArrayList (); ​ while(rs.next()){ ​ E element = class.forName(配置的全限定类名（即resultType）).newInstance（）; ​ 进行封装,把每个rs中的属性封装到element的属性之中 ​ 把element加入到list中 ​ list.add(element); ​ } ​ tip:在MyBatis中存在一个mapper对象，将Sql语句与封装结果的实体类全限定类名封装成一体 ​ 且存在一个map，用来保存实体类与其接口的对应关系。map的key为实体类的全限定类名（namespace属性）与接口的名称（id属性），value为sql语句与封装结果的全限定类名(resultType)。 ​ (5)返回list ​ ​ ​","categories":[],"tags":[]},{"title":"MyBatis学习笔记（三）","slug":"MyBatis学习笔记（三）","date":"2020-02-02T01:22:23.176Z","updated":"2020-02-02T00:56:23.313Z","comments":true,"path":"2020/02/02/MyBatis学习笔记（三）/","link":"","permalink":"http://yoursite.com/2020/02/02/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记（三）一、MyBatis连接池### 1.连接池：​ 在实际开发中，连接池会得到广泛应用，因为它可以减少获取连接的时间 2.MyBatis中的连接池​ MyBatis连接池提供3中方式的配置： ​ 配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性指定连接池的种类 ​ type属性取值: ​ POOLED 采用传统的javax.sql.DataSource规范中的连接池，MyBatis中有针对规范的实现 ​ UNPOOLED 采用传统的获取连接方式，虽然也实现了javax.sql.DataSource接口，但是并没有使用池的思想 ​ JNDI（*） 采用服务器提供的JNIDI技术实现，来获取DataSource对象，不同的服务器所能拿到的DataSource是不一样的，如果不是web或者maven的war工程，是不能使用的。 二、MyBatis中的事务（*自学）1.事务是什么 2.事务的四大特性ACID 3.不考虑隔离性会产生的3个问题 4.解决办法，四种隔离级别 三、MyBatis的事务自动提交MyBatis通过sqlSession对象的commit方法和rollback方法实现事务的提交和回滚 事务提交可通过调用session.commit()来提交事务,也可以通过MyBatis实现自动事务提交: 1session = factory.openSession(); 改成-&gt; 1session = factory.openSession(true); 即可 四、动态sql语句​ 在处理条件查询时，使用JDBC是一件很痛苦的事情。MyBatis提供了一种动态Sql语句的方式，来解决这个问题。为了处理这个问题，MyBatis主要提供了一下几个标签： 1.&#60;if&#62;标签​ 当查询方法传入了一个对象，要求根据对象的属性，查找数据库中与其匹配或相似的对象时，需要考虑该对象的部分属性为null或长度为0的问题。若直接用sql语句去写，很难处理。引入标签之后，可以增加一层判断，该问题就迎刃而解了。 ​ 举例：在findByUser方法中，我们传入一个User对象，要求根据用户名模糊查询，根据地址精确查寻。在原sql语句后加入“where 1=1”,再对用户名与地址是否为空进行判断，即可放心地在sql语句后完成操作。具体操作如下：(user使用了typeAlias进行了别名转换) 123456789&lt;select id = \"findByUser\" resultType=\"user\" parameter=\"user\"&gt; select * from user where 1 =1 &lt;if test =\"username!=null &amp;&amp; username.length()!=0&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test =\"address!=null\"&gt; and address = #&#123;address&#125; &lt;/if&gt; &lt;/select&gt; 2.&#60;where&#62;标签​ 简化where 1=1的条件拼装，可以采用标签来简化开发 ​ 即用标签可直接替换 where 1 = 1 1234567891011&lt;select id = \"findByUser\" resultType=\"user\" parameter=\"user\"&gt; select * from user &lt;where&gt; &lt;if test =\"username!=null &amp;&amp; username.length()!=0&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test =\"address!=null\"&gt; and address = #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3.&#60;foreach&#62;标签​ 当传入多个id查询用户信息，会使用下列sql语句： 1SELECT * FROM USERS WHERE id IN (10,89,16) ​ 当id以一个集合的形式通过参数传递传递过来时，可以使用标签，来遍历集合中的所有id，拼接完成sql语句。 ​ 具体实现： 123456789101112&lt;!-- 查询所有用户在 id的集合之中 --&gt;&lt;select id=\"findInIds\" resultType=\"user\" parameterType=\"queryvo\"&gt; &lt;!-- select * from user where id in (1,2,3,4,5); --&gt; select * from user &lt;where&gt; &lt;if test=\"ids != null and ids.size() &gt; 0\"&gt; &lt;foreach collection=\"ids\" open=\"id in ( \" close=\")\" item=\"uid\"separator=\",\"&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 标签用于遍历集合，它的属性： ​ collection:代表要遍历的集合元素，注意编写时不要写#{} ​ open:代表语句的开始部分 ​ close:代表结束部分 4. &#60;sql &#62; 标签​ 将重复的sql语句通过标签进行打包定义，后边进行引用即可 ​ 举例： ​ 定义代码片段： 1234&lt;!-- 抽取重复的语句代码片段 --&gt; &lt;sql id=\"defaultSql\"&gt; select * from user &lt;/sql&gt; ​ 引用代码片段： 1234&lt;!-- 配置查询所有操作 --&gt; &lt;select id=\"findAll\" resultType=\"user\"&gt; &lt;include refid=\"defaultSql\"&gt;&lt;/include&gt;&lt;/select&gt; 五、MyBAtis多表查询之一对多​ 举例： ​ 用户信息与账户信息是一个典型的一对多模型，一个用户可能拥有多个账户，但一个账户只能归于一个用户所有。 ​ 问题分析： ​ 我们要求实现： ​ 查询用户信息时，可以得到用户所拥有的账户信息 ​ 查询账户信息时，可以得到账户所属的用户信息 ​ 实现步骤 ​ 1.创建数据库用户表和账户表 ​ 2.创建用户实体类和账户实体类 ​ 3.创建用户配置信息和账户配置信息 ​ 4.完成配置 ​ 具体实现： ​ 账户到用户一对多： ​ 1.创建account表时需设置一个uid标识所属user对象 ​ 2..在Account类中加入User子类，并生成Getter&amp;Setter&amp;toString方法 ​ 3.IAccountDao中添加findAll方法 ​ 4.配置xml文件，用代理dao方式实现接口： ​ 定义accountUserMap: 1234567891011121314&lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"aid\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射，配置封装user的内容 --&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; ​ 引用accountUserMap，并添加sql语句： 1234&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"accountUserMap\"&gt; select a.* ,u.* from account a , user u where u.id=a.uid&lt;/select&gt; ​ 用户到账户多对一： ​ 1.在User类中加入Account集合引用，并生成Getter&amp;Setter&amp;toString方法 ​ 2.在接口中添加findAll方法 ​ 3.配置xml文件，用代理dao方式实现接口： ​ 定义userAccountMap： 1234567891011121314&lt;!-- 定义User的resultMap --&gt; &lt;resultMap id=\"userAccountMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;!-- 配置User对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"account\"&gt; &lt;id column=\"id1\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; ​ 引用userAccountMAp,并添加sql语句： 1234&lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; select * from user u left outer join account a on u.id=a.uid &lt;/select&gt; 六、MyBatis多表查询之多对多​ 举例： ​ 用户信息与角色信息是一个典型的多对多模型，一个用户可能扮演多个角色，一个角色也可能被多个用户所扮演。 ​ 问题分析： ​ 我们要求实现： ​ 查询用户信息时，可以得到用户所扮演的所有角色信息 ​ 查询角色信息时，可以得到角色所有的扮演者用户信息 ​ 实现步骤: ​ 1.创建数据库用户表和角色表以及中间关联表 ​ 2.创建用户实体类和角色实体类 ​ 3.创建用户配置信息和角色配置信息 ​ 4.完成配置 ​ 具体实现: ​ 基本步骤与上类似，此处只贴出sql语句： ​ 角色到用户: 123456&lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultMap=\"roleMap\"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt; ​ 用户到角色： 123456&lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from user u left outer join user_role ur on u.id = ur.uid left outer join role r on r.id = ur.rid &lt;/select&gt;","categories":[],"tags":[]},{"title":"MyBatis学习笔记（二）","slug":"MyBatis学习笔记（二）","date":"2020-02-02T01:22:23.173Z","updated":"2020-02-02T00:57:07.721Z","comments":true,"path":"2020/02/02/MyBatis学习笔记（二）/","link":"","permalink":"http://yoursite.com/2020/02/02/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记（二）一、MyBatis通过代理dao的方式实现CRUD操作1.编写步骤​ （1）在dao接口中创建相应的CRUD方法 ​ （2）配置xml文件： ​ 选择正确的标签（select insert update delete） ​ 配置id，resultType，parameter属性 ​ 配置sql语句 ​ （3）使用代理dao调用方法即可 2.parameter属性分析​ parameter属性可以设置成三种类型：简单类型，pojo对象，pojo的封装对象 ### （1）简单类型​ 直接传入简单类型名即可，不区分大小写 （2）pojo对象​ 传入对象的全限定类名。 ​ 由于MyBatis使用ognl表达式解析对象字段的值，在sql语句引用对象中的属性值时，可省略对象名.属性名的写法，直接写属性名即可 （3）pojo包装对象​ 有时查询需要用到不止一个对象的信息，则可以将多个对象封装在一个包装对象中，进行传递。 二、实体类属性与表列名不同时的转换处理​ 举例：在实体类中，User的属性为userId，userName，userAddress ​ 在数据库表中，User表的属性为id，username，address。 ​ 如果不进行一致性转换，那么resultset在封装的时候，会找不到封装目标属性，导致封装失败。 ​ 一致性转换有以下两种方法 1.改写sql语句，进行直接转换: (执行效率更高) 1select * from user ​ -&gt; 1select id as userId, username as userName, address as userAdress from user as 前时数据库表的列名，as后时java实体类的属性名 2.在映射配置文件(IUserDao.xml)中配置resultMap属性:（开发效率更高） 1234567&lt;resultMap id = \"userMap\" type = \"com.itheima.domain.User\"&gt; &lt;!-- 主键字段的对应 --&gt; &lt;id property=\"userId\" colomn=\"id\"&gt;&lt;/id&gt; &lt;!-- 非主键字段的对应 --&gt; &lt;result property=\"userName\" colomn=\"username\"&gt;&lt;/result&gt; &lt;result property=\"userAddress\" colomn=\"address\"&gt;&lt;/result&gt;&lt;/resultMap&gt; 然后在下面的各个有返回类型属性配置的sql语句配置中，使用resultMap代替resultType： 123&lt;select id=\"findAll\" resultMap=\"userMap\"&gt;select * form user&lt;/select&gt; 三、property标签的使用在配置数据库连接池的过程中需要用到property属性 12345678&lt;!-- 配置数据源(连接池) --&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/dataSource&gt; 也可以通过外联配置文件的方式来进行配置，此时需用properties标签指定外联配置文件的路径，再将property中的value改成引用的形式即可 123&lt;!-- jdbcConfig.properties中指定了数据库连接所需的driver,url,username,password等属性--&gt;&lt;properties resource = \"jdbcConfig.properties\"&gt;&lt;/properties&gt; 12345678&lt;!-- 配置数据源(连接池) --&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的基本信息 --&gt; &lt;property name=\"driver\" value=“$&#123;jdbc.driver&#125;”&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; 四、typeAlias与packege标签的使用typeAlias标签用于配置domain中类的别名，即可将全限定类名配置别名，使其使用更加简单: 12345&lt;typeAliases&gt; &lt;!-- type指定实体类的全限定类名，name指定别名 --&gt; &lt;!-- 配置别名之后，使用别名可以不再区分大小写 --&gt; &lt;typealias type=\"com.itheim.domain.user\" name=\"user\"&gt;&lt;/typealias&gt;&lt;/typeAliases&gt; 标签用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且别名就是类名。 同样，别名不再区分大小写 1234&lt;typeAliases&gt; &lt;package name=\"com.itheima.domain\"&gt;&lt;/package&gt;&lt;/typeAliases&gt;&lt;!--配置之后，domain下的所有实体类都被配置了别名，例如com.itheima.domain.user的别名为user--&gt;","categories":[],"tags":[]},{"title":"操作系统（七）--死锁","slug":"操作系统（七）-死锁","date":"2019-11-06T11:59:31.000Z","updated":"2019-11-06T15:08:57.088Z","comments":true,"path":"2019/11/06/操作系统（七）-死锁/","link":"","permalink":"http://yoursite.com/2019/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89-%E6%AD%BB%E9%94%81/","excerpt":"","text":"本篇博客分享《操作系统概念》中第七章–死锁部分的学习笔记。死锁是操作系统设计过程中必须着重考虑的一个环节，处理不得当会导致操作系统吞吐量大幅度降低，响应速度慢的结果。作为计算机学习者，我们应该掌握死锁的基本原理，以及如何处理死锁问题。 定义死锁的概念并不难理解，定义如下： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去 必要条件 互斥(mutual exclusion): 至少有一个资源是非共享的，即一次只有一个进程可以使用。这使得一个进程可能为了这个资源而等待另一个占有该资源的进程 占有并等待(hold and wait): 一个进程至少占有一个资源，并等待另一个资源。死锁是由许多进程各自占有对方的资源，又互不相让导致的。一个不占有资源的进程是不会导致死锁的。 非抢占(no preemption): 资源不能抢占。各个进程不给对方资源，却又很礼貌，不抢对方的资源。抢占式资源分配很少出现死锁 循环等待（circle wait）： 有一组等待进程{P0 , P1 , … , Pn},P0等待的资源为P1占有，P1等待的资源为P2占有, …… ,Pn-1等待的资源为Pn占有，Pn等待的资源为P0占有。死锁的资源分配图呈环状 死锁处理方法一般来说，死锁有四种处理方法: 1. 死锁预防 2. 死锁避免 3. 死锁检测与恢复 4. 忽略死锁，手动操作实际上，第四种处理方法看似称不上解决方案，但恰恰为大多数操作系统所采用，包括Linux和Windows。其中，处理死锁的代价是一个重要考量因素。对于许多系统，死锁出现频率很低（甚至一年一次），若使用频繁且开销昂贵的死锁预防、避免或是检测，会浪费大量资源，导致效率低下。相比之下，不处理却是最好的处理，开发人员需自行编写程序，处理死锁即可。 作为学习的需要，了解前三种死锁处理的机制以及分析它们的优缺点对我们大有裨益，以下将详细介绍这三种机制。 死锁预防死锁预防主要从死锁的四个必要条件入手，从根源阻断死锁的产生 互斥 可共享文件不要求互斥访问，因此不会产生死锁。 可读文件便是共享文件的一个例子，当多个文件试图共同读一个文件时，不会产生死锁的问题 但是通常不能通过互斥的角度预防死锁，因为很多资源本身就是非共享的，如互斥锁 持有并等待 该解决方案可理解为all or zero。即每个进程申请资源时，要么获得所有需要的资源，要么什么也得不到。 这种方案确实可以解决死锁问题，但是可能导致资源利用率低与饥饿两种问题 非抢占 改变系统为可抢占模式，则资源不会锁死在不同进程中，可以集中起来服务少数进程，并最终服务完所有进程。 这个协议通常用于状态可保存和恢复的资源，如CPU寄存器和内存。一般不适用于其他资源，如互斥锁和信号量 循环等待 将资源类型完全排序，并要求每个进程按递增顺序来申请资源，这样可以避免资源等待图中环的发生。 但是，设计一个完全排序或层次结构本身不能防止死锁，还要靠应用程序员按顺序编写程序。另外资源排序方式应该按正常使用顺序编排，不可随意排序。 死锁避免1.资源分配图算法 在一个每种资源只有一个实例的资源分配系统中，可用特殊的资源分配图来避免死锁。特殊资源分配图： 除了申请边和分配边（实线），我们引入一个需求边（虚线）。需求边Pi -&gt; Rj表示，进程Pj可能在将来某个时候申请资源Rj。 当请求发生时，需求边变成申请边。 当Pi释放Rj时，分配边变成需求边。 算法依据： 资源分配图中无环，则一定处于安全状态。 资源分配图中有环，则可能处于非安全状态。 算法描述： 假设Pi申请Rj。只有当申请边Pi-&gt;Rj变成分配边Rj-&gt;Pi并且资源分配图中不出现环是，才能允许申请。 银行家算法 适用于每种资源类型有多个实例的资源分配系统。该算法可用于银行系统，可确保银行不会分配现金，以致于它不再满足所有客户的需要。 算法描述： 当一个新的进程进入系统时，它应申明可能需要的每种类型资源实例的最大数量，这一数量不能超过系统资源的总和。当某进程申请一组资源时，系统应确定这些资源的分配是否会使系统不再安全。若是，则该进程等待，直到其他进程释放更多资源。否则，分配资源。 死锁检测 每种资源类型只有单个实例： 维护等待图。当且仅当等待图中有环，出现死锁。 每种资源类型有多个实例： 维护类似于银行家算法的多个矩阵图。比较Need矩阵与available向量的大小。 死锁恢复 进程终止1） 终止所有进程：可打破死锁，但是代价巨大。当进程重新计算时，要耗费大量的时间。2） 逐个终止进程，直至消除死锁循环：每次终止一个进程，都将调用死锁检测算法，开销大。并且指定规则，确定每次终止的进程。 资源抢占 资源抢占可解决死锁问题，但是要处理好三个问题： 1） 如何选择牺牲进程：根据代价最小原则确定抢占顺序 2） 回滚：合理处理被抢占进程 3） 饥饿：应设置进程被抢占次数的上限，避免其被无限抢占而节。","categories":[],"tags":[]},{"title":"计算机网络--逻辑链路层","slug":"逻辑链路层","date":"2019-11-05T03:52:24.000Z","updated":"2019-11-06T08:09:18.281Z","comments":true,"path":"2019/11/05/逻辑链路层/","link":"","permalink":"http://yoursite.com/2019/11/05/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"一、概述 数据链路层使用物理层提供的服务在通信信道上发送和接受比特。 二、功能 向网络层提供一个定义良好的服务接口 处理传输错误 调节数据流，确保慢速的接收方不会被快速的接收方淹没 三、服务向网络层提供以下三种服务： 无确认的无连接服务 有确认的无连接服务 有确认的有连接服务 四、成帧 字节计数法 字节填充的标志字节法: 用标志字节FLAG来代表一帧的开始和结束，并用转义字符ESC来解决透明传输问题 例题: Answer: ESC ESC C ESC ESC ESC FLAG G ESC FLAG D 比特填充的标志比特法011111110或十六进制0x7E作为标志字节。若传输的数据遇到连续五个1，则在其后添加一个0，打断六个以上的连续1字节流 物理层编码违禁法","categories":[],"tags":[]}]}