{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"MyBatis学习笔记（一）","slug":"MyBatis学习笔记（一）","date":"2020-02-02T01:22:23.180Z","updated":"2020-02-02T01:03:08.330Z","comments":true,"path":"2020/02/02/MyBatis学习笔记（一）/","link":"","permalink":"http://yoursite.com/2020/02/02/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记 （一）本系列笔记学习的是黑马程序员推出的ssm系列课程，感谢老师的精彩讲解，在此立贴以示感激。 一、MyBatis概述​ MyBatis是一款优秀的Java持久层框架，它封装了JDBC，使开发者只需要关注Sql语句本身，二不需要花费精力去处理加载驱动，创建连接、创建Statement等繁杂的过程 ​ MyBatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由MyBatis框架执行sql并将结果映射为java对象并返回。 ​ 采用ORM思想解决了实体和数据库映射的问题，对JDBC进行了封装，屏蔽了JDBC API底层访问细节，是我们不用与JDBC API打交道，就可以完成对数据库的持久化操作。 二、环境搭建1.创建maven工程并导入坐标，即在pom.xml中添加依赖（包括mybatis，mysql，log4j，junit)： 2.创建数据库表以及对应的Java实体类3.创建dao接口​ 4.创建MyBatis的主配置文件（SqlMapConfig.xml):​ ​ 5.创建映射配置文件（IUserDao.xml）： 注意事项：​ 1.在MyBatis中，dao常被成为Mapper ​ 2.包与目录的创建方式不同： ​ 例如：com.itheima.IUserDao以packege方式创建是三级目录， ​ 以目录方式创建是一级目录。 ​ 3.MyBatis的映射文件和Dao接口的包结构必须相同。（即IUserDao.xml与IUserDao.java的包结构必须相同） ​ 4.映射配置文件的mapper的namespace属性必须是dao接口的全限定类名 ​ 5.映射配置文件的操作配置id属性必须是dao接口的方法名 三、入门案例### 1.步骤： 2.设计模式：3.过程分析：​ （1）解析主配置文件获取数据库连接： ​ MyBatis据此自动注册驱动，获取连接，创建connection对象​ （2）解析映射配置文件： ​ 获取执行的sql语句，MyBatis据此构造preparedStatement。 ​ （3）执行查询操作： ​ ResultSet rs = preparedStatemnt.executeQuery(); ​ (4) 遍历结果集并封装 ​ List list = new ArrayList (); ​ while(rs.next()){ ​ E element = class.forName(配置的全限定类名（即resultType）).newInstance（）; ​ 进行封装,把每个rs中的属性封装到element的属性之中 ​ 把element加入到list中 ​ list.add(element); ​ } ​ tip:在MyBatis中存在一个mapper对象，将Sql语句与封装结果的实体类全限定类名封装成一体 ​ 且存在一个map，用来保存实体类与其接口的对应关系。map的key为实体类的全限定类名（namespace属性）与接口的名称（id属性），value为sql语句与封装结果的全限定类名(resultType)。 ​ (5)返回list ​ ​ ​","categories":[],"tags":[]},{"title":"MyBatis学习笔记（三）","slug":"MyBatis学习笔记（三）","date":"2020-02-02T01:22:23.176Z","updated":"2020-02-02T00:56:23.313Z","comments":true,"path":"2020/02/02/MyBatis学习笔记（三）/","link":"","permalink":"http://yoursite.com/2020/02/02/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记（三）一、MyBatis连接池### 1.连接池：​ 在实际开发中，连接池会得到广泛应用，因为它可以减少获取连接的时间 2.MyBatis中的连接池​ MyBatis连接池提供3中方式的配置： ​ 配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性指定连接池的种类 ​ type属性取值: ​ POOLED 采用传统的javax.sql.DataSource规范中的连接池，MyBatis中有针对规范的实现 ​ UNPOOLED 采用传统的获取连接方式，虽然也实现了javax.sql.DataSource接口，但是并没有使用池的思想 ​ JNDI（*） 采用服务器提供的JNIDI技术实现，来获取DataSource对象，不同的服务器所能拿到的DataSource是不一样的，如果不是web或者maven的war工程，是不能使用的。 二、MyBatis中的事务（*自学）1.事务是什么 2.事务的四大特性ACID 3.不考虑隔离性会产生的3个问题 4.解决办法，四种隔离级别 三、MyBatis的事务自动提交MyBatis通过sqlSession对象的commit方法和rollback方法实现事务的提交和回滚 事务提交可通过调用session.commit()来提交事务,也可以通过MyBatis实现自动事务提交: 1session = factory.openSession(); 改成-&gt; 1session = factory.openSession(true); 即可 四、动态sql语句​ 在处理条件查询时，使用JDBC是一件很痛苦的事情。MyBatis提供了一种动态Sql语句的方式，来解决这个问题。为了处理这个问题，MyBatis主要提供了一下几个标签： 1.&#60;if&#62;标签​ 当查询方法传入了一个对象，要求根据对象的属性，查找数据库中与其匹配或相似的对象时，需要考虑该对象的部分属性为null或长度为0的问题。若直接用sql语句去写，很难处理。引入标签之后，可以增加一层判断，该问题就迎刃而解了。 ​ 举例：在findByUser方法中，我们传入一个User对象，要求根据用户名模糊查询，根据地址精确查寻。在原sql语句后加入“where 1=1”,再对用户名与地址是否为空进行判断，即可放心地在sql语句后完成操作。具体操作如下：(user使用了typeAlias进行了别名转换) 123456789&lt;select id = \"findByUser\" resultType=\"user\" parameter=\"user\"&gt; select * from user where 1 =1 &lt;if test =\"username!=null &amp;&amp; username.length()!=0&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test =\"address!=null\"&gt; and address = #&#123;address&#125; &lt;/if&gt; &lt;/select&gt; 2.&#60;where&#62;标签​ 简化where 1=1的条件拼装，可以采用标签来简化开发 ​ 即用标签可直接替换 where 1 = 1 1234567891011&lt;select id = \"findByUser\" resultType=\"user\" parameter=\"user\"&gt; select * from user &lt;where&gt; &lt;if test =\"username!=null &amp;&amp; username.length()!=0&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test =\"address!=null\"&gt; and address = #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3.&#60;foreach&#62;标签​ 当传入多个id查询用户信息，会使用下列sql语句： 1SELECT * FROM USERS WHERE id IN (10,89,16) ​ 当id以一个集合的形式通过参数传递传递过来时，可以使用标签，来遍历集合中的所有id，拼接完成sql语句。 ​ 具体实现： 123456789101112&lt;!-- 查询所有用户在 id的集合之中 --&gt;&lt;select id=\"findInIds\" resultType=\"user\" parameterType=\"queryvo\"&gt; &lt;!-- select * from user where id in (1,2,3,4,5); --&gt; select * from user &lt;where&gt; &lt;if test=\"ids != null and ids.size() &gt; 0\"&gt; &lt;foreach collection=\"ids\" open=\"id in ( \" close=\")\" item=\"uid\"separator=\",\"&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 标签用于遍历集合，它的属性： ​ collection:代表要遍历的集合元素，注意编写时不要写#{} ​ open:代表语句的开始部分 ​ close:代表结束部分 4. &#60;sql &#62; 标签​ 将重复的sql语句通过标签进行打包定义，后边进行引用即可 ​ 举例： ​ 定义代码片段： 1234&lt;!-- 抽取重复的语句代码片段 --&gt; &lt;sql id=\"defaultSql\"&gt; select * from user &lt;/sql&gt; ​ 引用代码片段： 1234&lt;!-- 配置查询所有操作 --&gt; &lt;select id=\"findAll\" resultType=\"user\"&gt; &lt;include refid=\"defaultSql\"&gt;&lt;/include&gt;&lt;/select&gt; 五、MyBAtis多表查询之一对多​ 举例： ​ 用户信息与账户信息是一个典型的一对多模型，一个用户可能拥有多个账户，但一个账户只能归于一个用户所有。 ​ 问题分析： ​ 我们要求实现： ​ 查询用户信息时，可以得到用户所拥有的账户信息 ​ 查询账户信息时，可以得到账户所属的用户信息 ​ 实现步骤 ​ 1.创建数据库用户表和账户表 ​ 2.创建用户实体类和账户实体类 ​ 3.创建用户配置信息和账户配置信息 ​ 4.完成配置 ​ 具体实现： ​ 账户到用户一对多： ​ 1.创建account表时需设置一个uid标识所属user对象 ​ 2..在Account类中加入User子类，并生成Getter&amp;Setter&amp;toString方法 ​ 3.IAccountDao中添加findAll方法 ​ 4.配置xml文件，用代理dao方式实现接口： ​ 定义accountUserMap: 1234567891011121314&lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"aid\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射，配置封装user的内容 --&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; ​ 引用accountUserMap，并添加sql语句： 1234&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"accountUserMap\"&gt; select a.* ,u.* from account a , user u where u.id=a.uid&lt;/select&gt; ​ 用户到账户多对一： ​ 1.在User类中加入Account集合引用，并生成Getter&amp;Setter&amp;toString方法 ​ 2.在接口中添加findAll方法 ​ 3.配置xml文件，用代理dao方式实现接口： ​ 定义userAccountMap： 1234567891011121314&lt;!-- 定义User的resultMap --&gt; &lt;resultMap id=\"userAccountMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;!-- 配置User对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"account\"&gt; &lt;id column=\"id1\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; ​ 引用userAccountMAp,并添加sql语句： 1234&lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; select * from user u left outer join account a on u.id=a.uid &lt;/select&gt; 六、MyBatis多表查询之多对多​ 举例： ​ 用户信息与角色信息是一个典型的多对多模型，一个用户可能扮演多个角色，一个角色也可能被多个用户所扮演。 ​ 问题分析： ​ 我们要求实现： ​ 查询用户信息时，可以得到用户所扮演的所有角色信息 ​ 查询角色信息时，可以得到角色所有的扮演者用户信息 ​ 实现步骤: ​ 1.创建数据库用户表和角色表以及中间关联表 ​ 2.创建用户实体类和角色实体类 ​ 3.创建用户配置信息和角色配置信息 ​ 4.完成配置 ​ 具体实现: ​ 基本步骤与上类似，此处只贴出sql语句： ​ 角色到用户: 123456&lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultMap=\"roleMap\"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt; ​ 用户到角色： 123456&lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from user u left outer join user_role ur on u.id = ur.uid left outer join role r on r.id = ur.rid &lt;/select&gt;","categories":[],"tags":[]},{"title":"MyBatis学习笔记（二）","slug":"MyBatis学习笔记（二）","date":"2020-02-02T01:22:23.173Z","updated":"2020-02-02T00:57:07.721Z","comments":true,"path":"2020/02/02/MyBatis学习笔记（二）/","link":"","permalink":"http://yoursite.com/2020/02/02/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记（二）一、MyBatis通过代理dao的方式实现CRUD操作1.编写步骤​ （1）在dao接口中创建相应的CRUD方法 ​ （2）配置xml文件： ​ 选择正确的标签（select insert update delete） ​ 配置id，resultType，parameter属性 ​ 配置sql语句 ​ （3）使用代理dao调用方法即可 2.parameter属性分析​ parameter属性可以设置成三种类型：简单类型，pojo对象，pojo的封装对象 ### （1）简单类型​ 直接传入简单类型名即可，不区分大小写 （2）pojo对象​ 传入对象的全限定类名。 ​ 由于MyBatis使用ognl表达式解析对象字段的值，在sql语句引用对象中的属性值时，可省略对象名.属性名的写法，直接写属性名即可 （3）pojo包装对象​ 有时查询需要用到不止一个对象的信息，则可以将多个对象封装在一个包装对象中，进行传递。 二、实体类属性与表列名不同时的转换处理​ 举例：在实体类中，User的属性为userId，userName，userAddress ​ 在数据库表中，User表的属性为id，username，address。 ​ 如果不进行一致性转换，那么resultset在封装的时候，会找不到封装目标属性，导致封装失败。 ​ 一致性转换有以下两种方法 1.改写sql语句，进行直接转换: (执行效率更高) 1select * from user ​ -&gt; 1select id as userId, username as userName, address as userAdress from user as 前时数据库表的列名，as后时java实体类的属性名 2.在映射配置文件(IUserDao.xml)中配置resultMap属性:（开发效率更高） 1234567&lt;resultMap id = \"userMap\" type = \"com.itheima.domain.User\"&gt; &lt;!-- 主键字段的对应 --&gt; &lt;id property=\"userId\" colomn=\"id\"&gt;&lt;/id&gt; &lt;!-- 非主键字段的对应 --&gt; &lt;result property=\"userName\" colomn=\"username\"&gt;&lt;/result&gt; &lt;result property=\"userAddress\" colomn=\"address\"&gt;&lt;/result&gt;&lt;/resultMap&gt; 然后在下面的各个有返回类型属性配置的sql语句配置中，使用resultMap代替resultType： 123&lt;select id=\"findAll\" resultMap=\"userMap\"&gt;select * form user&lt;/select&gt; 三、property标签的使用在配置数据库连接池的过程中需要用到property属性 12345678&lt;!-- 配置数据源(连接池) --&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/dataSource&gt; 也可以通过外联配置文件的方式来进行配置，此时需用properties标签指定外联配置文件的路径，再将property中的value改成引用的形式即可 123&lt;!-- jdbcConfig.properties中指定了数据库连接所需的driver,url,username,password等属性--&gt;&lt;properties resource = \"jdbcConfig.properties\"&gt;&lt;/properties&gt; 12345678&lt;!-- 配置数据源(连接池) --&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的基本信息 --&gt; &lt;property name=\"driver\" value=“$&#123;jdbc.driver&#125;”&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; 四、typeAlias与packege标签的使用typeAlias标签用于配置domain中类的别名，即可将全限定类名配置别名，使其使用更加简单: 12345&lt;typeAliases&gt; &lt;!-- type指定实体类的全限定类名，name指定别名 --&gt; &lt;!-- 配置别名之后，使用别名可以不再区分大小写 --&gt; &lt;typealias type=\"com.itheim.domain.user\" name=\"user\"&gt;&lt;/typealias&gt;&lt;/typeAliases&gt; 标签用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且别名就是类名。 同样，别名不再区分大小写 1234&lt;typeAliases&gt; &lt;package name=\"com.itheima.domain\"&gt;&lt;/package&gt;&lt;/typeAliases&gt;&lt;!--配置之后，domain下的所有实体类都被配置了别名，例如com.itheima.domain.user的别名为user--&gt;","categories":[],"tags":[]},{"title":"期末项目需求文档（初稿）","slug":"期末项目需求文档（初稿）","date":"2019-11-13T08:08:36.921Z","updated":"2019-11-13T08:07:49.804Z","comments":true,"path":"2019/11/13/期末项目需求文档（初稿）/","link":"","permalink":"http://yoursite.com/2019/11/13/%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3%EF%BC%88%E5%88%9D%E7%A8%BF%EF%BC%89/","excerpt":"","text":"一.项目名称图像信息管理系统（极简版） 二.项目技术前端： html,css,JavaScript后端： JSP,Servelt数据库：JDBC,MYSQL 项目环境：Windows , Eclipse , JDK11 , Tomcat 功能模块分析 登录页面 注册页面 图像展示页面 图像管理页面 用户数据库（记录用户信息：用户名，密码，性别，拥有的图片 等等） 功能模块说明 登录，注册页面参照主流的即可 图像展示页面主要有三个内容：a.图片上传按钮，点击后可跳转到图片上传页面b.用户图片列表：列出所有用户已上传的图片超链接c.用户图片展示区：每一个图片超链接被点击后，会在此展示区显示该图片。并显示出图片的相关信息，如 图片管理页面：用户可在此进行图片的增删改查，如图像国别；图像具体位置；分辨率；经纬度；采集时间；采集时长；比例尺。 关于页面设计，后端工程师用jsp给出整体框架，前端工程师主要负责用css或JavaScript代码将其美化","categories":[],"tags":[]},{"title":"操作系统（七）--死锁","slug":"操作系统（七）-死锁","date":"2019-11-06T11:59:31.000Z","updated":"2019-11-06T15:08:57.088Z","comments":true,"path":"2019/11/06/操作系统（七）-死锁/","link":"","permalink":"http://yoursite.com/2019/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89-%E6%AD%BB%E9%94%81/","excerpt":"","text":"本篇博客分享《操作系统概念》中第七章–死锁部分的学习笔记。死锁是操作系统设计过程中必须着重考虑的一个环节，处理不得当会导致操作系统吞吐量大幅度降低，响应速度慢的结果。作为计算机学习者，我们应该掌握死锁的基本原理，以及如何处理死锁问题。 定义死锁的概念并不难理解，定义如下： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去 必要条件 互斥(mutual exclusion): 至少有一个资源是非共享的，即一次只有一个进程可以使用。这使得一个进程可能为了这个资源而等待另一个占有该资源的进程 占有并等待(hold and wait): 一个进程至少占有一个资源，并等待另一个资源。死锁是由许多进程各自占有对方的资源，又互不相让导致的。一个不占有资源的进程是不会导致死锁的。 非抢占(no preemption): 资源不能抢占。各个进程不给对方资源，却又很礼貌，不抢对方的资源。抢占式资源分配很少出现死锁 循环等待（circle wait）： 有一组等待进程{P0 , P1 , … , Pn},P0等待的资源为P1占有，P1等待的资源为P2占有, …… ,Pn-1等待的资源为Pn占有，Pn等待的资源为P0占有。死锁的资源分配图呈环状 死锁处理方法一般来说，死锁有四种处理方法: 1. 死锁预防 2. 死锁避免 3. 死锁检测与恢复 4. 忽略死锁，手动操作实际上，第四种处理方法看似称不上解决方案，但恰恰为大多数操作系统所采用，包括Linux和Windows。其中，处理死锁的代价是一个重要考量因素。对于许多系统，死锁出现频率很低（甚至一年一次），若使用频繁且开销昂贵的死锁预防、避免或是检测，会浪费大量资源，导致效率低下。相比之下，不处理却是最好的处理，开发人员需自行编写程序，处理死锁即可。 作为学习的需要，了解前三种死锁处理的机制以及分析它们的优缺点对我们大有裨益，以下将详细介绍这三种机制。 死锁预防死锁预防主要从死锁的四个必要条件入手，从根源阻断死锁的产生 互斥 可共享文件不要求互斥访问，因此不会产生死锁。 可读文件便是共享文件的一个例子，当多个文件试图共同读一个文件时，不会产生死锁的问题 但是通常不能通过互斥的角度预防死锁，因为很多资源本身就是非共享的，如互斥锁 持有并等待 该解决方案可理解为all or zero。即每个进程申请资源时，要么获得所有需要的资源，要么什么也得不到。 这种方案确实可以解决死锁问题，但是可能导致资源利用率低与饥饿两种问题 非抢占 改变系统为可抢占模式，则资源不会锁死在不同进程中，可以集中起来服务少数进程，并最终服务完所有进程。 这个协议通常用于状态可保存和恢复的资源，如CPU寄存器和内存。一般不适用于其他资源，如互斥锁和信号量 循环等待 将资源类型完全排序，并要求每个进程按递增顺序来申请资源，这样可以避免资源等待图中环的发生。 但是，设计一个完全排序或层次结构本身不能防止死锁，还要靠应用程序员按顺序编写程序。另外资源排序方式应该按正常使用顺序编排，不可随意排序。 死锁避免1.资源分配图算法 在一个每种资源只有一个实例的资源分配系统中，可用特殊的资源分配图来避免死锁。特殊资源分配图： 除了申请边和分配边（实线），我们引入一个需求边（虚线）。需求边Pi -&gt; Rj表示，进程Pj可能在将来某个时候申请资源Rj。 当请求发生时，需求边变成申请边。 当Pi释放Rj时，分配边变成需求边。 算法依据： 资源分配图中无环，则一定处于安全状态。 资源分配图中有环，则可能处于非安全状态。 算法描述： 假设Pi申请Rj。只有当申请边Pi-&gt;Rj变成分配边Rj-&gt;Pi并且资源分配图中不出现环是，才能允许申请。 银行家算法 适用于每种资源类型有多个实例的资源分配系统。该算法可用于银行系统，可确保银行不会分配现金，以致于它不再满足所有客户的需要。 算法描述： 当一个新的进程进入系统时，它应申明可能需要的每种类型资源实例的最大数量，这一数量不能超过系统资源的总和。当某进程申请一组资源时，系统应确定这些资源的分配是否会使系统不再安全。若是，则该进程等待，直到其他进程释放更多资源。否则，分配资源。 死锁检测 每种资源类型只有单个实例： 维护等待图。当且仅当等待图中有环，出现死锁。 每种资源类型有多个实例： 维护类似于银行家算法的多个矩阵图。比较Need矩阵与available向量的大小。 死锁恢复 进程终止1） 终止所有进程：可打破死锁，但是代价巨大。当进程重新计算时，要耗费大量的时间。2） 逐个终止进程，直至消除死锁循环：每次终止一个进程，都将调用死锁检测算法，开销大。并且指定规则，确定每次终止的进程。 资源抢占 资源抢占可解决死锁问题，但是要处理好三个问题： 1） 如何选择牺牲进程：根据代价最小原则确定抢占顺序 2） 回滚：合理处理被抢占进程 3） 饥饿：应设置进程被抢占次数的上限，避免其被无限抢占而节。","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2019-11-05T05:24:38.766Z","updated":"2019-11-05T05:26:55.752Z","comments":true,"path":"2019/11/05/test/","link":"","permalink":"http://yoursite.com/2019/11/05/test/","excerpt":"","text":"h1h2h3h4h5一级标题二级标题 hello1 hello2 hello3 12345public static void main (String args[])&#123; int a,b ; int c = a+b ; System.out.println (c);&#125; github{:target=”_blank”}百度$$ x \\href{why-equal.html}{=} y^2 + 1 $$","categories":[],"tags":[]},{"title":"计算机网络--逻辑链路层","slug":"逻辑链路层","date":"2019-11-05T03:52:24.000Z","updated":"2019-11-06T08:09:18.281Z","comments":true,"path":"2019/11/05/逻辑链路层/","link":"","permalink":"http://yoursite.com/2019/11/05/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"一、概述 数据链路层使用物理层提供的服务在通信信道上发送和接受比特。 二、功能 向网络层提供一个定义良好的服务接口 处理传输错误 调节数据流，确保慢速的接收方不会被快速的接收方淹没 三、服务向网络层提供以下三种服务： 无确认的无连接服务 有确认的无连接服务 有确认的有连接服务 四、成帧 字节计数法 字节填充的标志字节法: 用标志字节FLAG来代表一帧的开始和结束，并用转义字符ESC来解决透明传输问题 例题: Answer: ESC ESC C ESC ESC ESC FLAG G ESC FLAG D 比特填充的标志比特法011111110或十六进制0x7E作为标志字节。若传输的数据遇到连续五个1，则在其后添加一个0，打断六个以上的连续1字节流 物理层编码违禁法","categories":[],"tags":[]}]}