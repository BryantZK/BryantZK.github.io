{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Spring学习笔记（二）","slug":"Spring学习笔记（二）","date":"2020-02-11T04:38:32.889Z","updated":"2020-02-11T04:37:56.116Z","comments":true,"path":"2020/02/11/Spring学习笔记（二）/","link":"","permalink":"http://yoursite.com/2020/02/11/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"Spring学习笔记（二）​ 今日学习的主要内容，是基于注解的IOC配置以及Spring整合JUnit的测试操作。注解开发分为两个部分： 常用注解与新注解。常用注解主要用于配置自己编写的类，而新注解用于配置引用的无法修改的类。常用注解的使用可以明显地简化开发，但新注解常常使步骤更加繁琐。所以，我们在开发中应保持一下原则：自己编写的类使用常用注解，引用的类采用xml配置。 ​ ​ 在讲解常用注解之前，首先要注意环境配置。 ​ 在xml配置的基础上，只需要1)更改约束，2)添加一句xml语句指定创建IOC容器要扫描的包即可： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 一、常用注解​ Spring的常用注解分为四类：用于创建对象的（4），用于注入数据的（4），用于控制作用范围的（1），与生命周期相关的（2）。 1、用于创建对象的​ 相当于 ​ 1） @Component： ​ 作用：把对象交给Spring来管理，相当于在xml中配bean ​ 位置：在对象类的上方 ​ 属性：value属性：指定bean的id。若不指定value，则bean的默认id是当前类的类名（首字母小写） ​ 示例：在本例中，备注解的类AccountDaoImpl，在IOC容器中被创建，且id为accountDao 123@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123;&#125; ​ 2）@Controller @Service @Repository ​ 这三个注解的作用、位置、属性与@Component完全相同，只不过@Controller常用在控制层类前，@Service常用在业务层类前，@Repository常用在持久层类前 2、用于注入数据的​ 相当于或 ​ 1） @Autowired ​ 作用:自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他bean类型。当IOC容器中有多个bean类型与之匹配时，使用要注入的对象变量名称作为bean的id，在Spring容器中查找key，找到相同也可成功注入。找不到则报错 ​ 示例： 1234public class AccountDaoImpl implements IAccountDao &#123; @Autowired private AccountDaoImpl accountDao;&#125; ​ 2）@Qualifier ​ 作用：在自动按照类型的基础上，在按照Bean的id注入。它在给字段注入时不能独立使用，必须和@Autowired一起使用；但是给方法参数注入时，可以单独使用。 ​ （相当于Autowired是狙击枪，Qualifier是瞄准镜，可以根据id更好地定位，以解决IOC容器中有多个bean类型与被注解bena对象类型匹配的问题） ​ 属性：value：指定bean的id ​ 示例： 12345public class AccountDaoImpl implements IAccountDao &#123; @Autowired @Qualifier(\"accountDao\") private AccountDaoImpl accountDao;&#125; ​ 3)@Resource ​ 作用：直接按照Bean的id注入。相当于Autowired与Qualified的整合，也只能注入bean对象 ​ 属性：name：指定bean的id 1234public class AccountDaoImpl implements IAccountDao &#123; @Resource(name=\"accountDao\") private AccountDaoImpl accountDao;&#125; ​ 4)@Value ​ 作用：注入基本类型的数据和String类型的数据 ​ 属性：value：用于指定值 ​ 示例： 123456public class AccountDaoImpl implements IAccountDao &#123; @Value(value=\"12.0\") private Double money; @Value(\"xioawang\") private String name;&#125; 3、用于改变作用范围的​ 相当于 ​ 1）@Scope ​ 作用：指定bean的作用范围 ​ 属性：value：指定范围的值： ​ 取值：singleton protoType request session globalsession 4、与生命周期相关的（了解）​ 相当于 ​ 1）@PostConstruct ​ 作用：用于定义初始化方法 ​ 2）@PreDestroy ​ 作用： 用于指定销毁方法 二、新注解​ 1.@Component ​ 作用：用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext（有@Component注解的类.class) ​ 属性：value：用于指定配置类的字节码 ​ 示例： 123@Configuration public class SpringConfiguration &#123;&#125; ​ 2.@ComponentScan ​ 作用：用于指定Spring在创建初始化IOC容器时要扫描的包。作用和在xml配置中的： &lt;context:component-scan base-package=”com.itheima”/&gt;是一样的 ​ 属性：backPackages/value:用于指定要扫描的包。 ​ 示例： 1234@Configuration @ComponentScan(\"com.itheima\") public class SpringConfiguration &#123;&#125; ​ 3.@Bean ​ 作用：该注解只能卸方法上，表明使用此方法创建一个对象，并存入Spring容器。 ​ 属性：name：给当前@Bean注解方法创建的对象指定一个名称（即bean的id） ​ 示例： 12345678910111213141516171819public class JdbcConfig &#123; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name=\"dataSource\") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setUser(\"root\"); ds.setPassword(\"1234\"); ds.setDriverClass(\"com.mysql.jdbc.Driver\"); ds.setJdbcUrl(\"jdbc:mysql:///spring_day02\"); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 创建一个 DBAssit，并且也存入 spring 容器中 * @param dataSource * @return */ @Bean(name=\"dbAssit\") public DBAssit createDBAssit(DataSource dataSource) &#123; return new DBAssit(dataSourc e); &#125; &#125; ​ 4.@Import ​ 作用: 用于在主配置文件中，引入从配置文件。从配置文件可以不写@Configuration注解，但是写了也不报错。 ​ 属性：value[]：用于指定其他配置类的字节码 ​ 示例： 123456789@Configuration @ComponentScan(basePackages = \"com.itheima.spring\") @Import(&#123; JdbcConfig.class&#125;) public class SpringConfiguration &#123; &#125;@Configurationpublic class JdbcConfig&#123;&#125; ​ 5.@PropertySource ​ 作用：用于加载properties文件中的配置。例如我们配置数据源时，可以把数据库的连接信息写在properties配置文件中，就可以使用此注解指定properties配置文件的位置。 ​ 属性：value[]:用于指定properties文件位置。如果是类路径下，需要写上classPath: ​ 示例： 有一个jdbConfig.properties文件,指定了数据库连接的信息： 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/test?serverTimeZone=UTCjdbc.username=rootjdbc.password=123456 且有一个数据库信息配置类通过自动注入的方式注入这些信息； 1234567891011public class jdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver ; @Value(\"$&#123;jdbc.url&#125;\") private String url ; @Value(\"$&#123;jdbc.username&#125;\") private String username ; @Value(\"$&#123;jdbc.password&#125;\") private String password ;&#125; 但要想java类能够找到这些信息，必须有一个注解来告诉它，去哪儿可以找到这些el表达式指定的值。 即用propertySource注解来指定properties文件 123456@Configuration@ComponentScan(\"com.itheima\")@Import(jdbcConfig.class)@PropertySource(\"jdbc.properties\")public class SpringConfiguration &#123;&#125; 三、Spring与Junit的整合​ 问题 ​ 在测试类中，每个测试方法都有以下两行代码： 123ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");IAccountService as = ac.getBean(\"accountService\",IAccountService.class); ​ 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 ​ 解决方法 ​ 但是通过Spring框架与JUnit的整合，它可以提供一个运行器，可以读取配置文件（或注解）来创建容器，我们只需要告诉它配置文件在哪儿即可。 ​ 配置步骤： ​ 1.拷贝整个JUnit的必备jar包到lib目录。（IDEA编写pom.xml可自动导包） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; ​ 2.使用@RunWith注解替换原有运行器 123@RunWith(SpringJUnit4ClassRunner.class) public class AccountServiceTest &#123;&#125; ​ 3.使用@ContextConfiguration指定Spring配置文件的位置 1234@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= &#123;\"classpath:bean.xml\"&#125;) public class AccountServiceTest &#123;&#125; ​ 4.使用@Autowired给测试类的变量注入数据 12345@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;\"classpath:bean.xml\"&#125;)public class AccountServiceTest &#123; @Autowired private IAccountService as ;&#125;","categories":[],"tags":[]},{"title":"Spring学习笔记（一）","slug":"Spring学习笔记（一）","date":"2020-02-09T02:31:07.892Z","updated":"2020-02-09T02:30:27.145Z","comments":true,"path":"2020/02/09/Spring学习笔记（一）/","link":"","permalink":"http://yoursite.com/2020/02/09/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Spring学习笔记（一）​ MyBatis的学习已经告一段落了，持久层往上就到了服务层。服务层的技术便是我们顶顶大名的spring。 一、Spring概述​ Spring是一款javaEE轻量级开源框架，以IOC（反转控制）和AOP（面向切面编程）为内核，提供了SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架，和类库，逐渐成为使用最多的JavaEE企业应用开源框架。 二、Spring的优势​ 1.方便解耦，简化开发 ​ 2.AOP编程的支持 ​ 3.声明式事务的支持 ​ 4.方便程序的测试 ​ 5.方便集成各种优秀框架 ​ 6.降低JavaEE的使用难度 ​ 7.Spring源码是经典的学习案例 三、程序耦合​ 在讲解Spring的一大核心IOC之前，我们首先要弄明白什么是程序的耦合。 ​ 在这里引入一小段耦合的概念，看不懂一笑而过即可。 在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计 应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。 ​ 用通俗的话来说，耦合就是程序尤其是对象之间的关联程度。关联程度越高，我们修改代码时，需要修改的地方就越多。这样既会导致维护成本提高，也会致使出错的概率提升。所以我们要尽量减少程序间的关联程度，即耦合度。 ​ 耦合有以下分类： 1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另 一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大 量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进 行适当的动作，这种耦合被称为控制耦合。 5） 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。 6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另 一些模块的输入数据。 7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 ​ ​ 总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在编写程序的过程中，我们应采取一下原则：如果模块间必须存在耦合，那么尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免内容耦合 四、程序解耦举例​ 我们可以将解耦理解成一句话，即：做到程序编译器不报错，运行期才报错 ​ 以JDBC基本操作为例，我们在注册驱动时可以采用以下的写法： 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); ​ 由于我们采用了new关键字，一旦我们将mysql驱动的jar包删除，这条语句将在编译器就会报错，这体现出JDBC与Driver类的耦合度过高。 ​ 要想降低两者之间的耦合度，可以用反射的机制来注册驱动： 1Class.forName(\"com.mysql.jdbc.Driver\");//此处只是一个字符串 ​ 采用这种写法，即使删除jar包，编译器也不会报错，这便实现了解耦。（当然程序是无法运行的，在运行期必然会报错。） ​ 实际上一种更常见的解耦方式就是采用工厂模式来实现控制反转（IOC） 五、IOC–控制反转​ 概念： 控制反转把创建对象的权利交给框架，是框架的重要特征，并非面向对象编程的专用术语。它包括依赖注入和依赖查找 ​ 作用： 削减计算机·程序的耦合，降低程序间的以来关系 ​ 分析： ​ 原来我们获取对象时，采用new的方式，是主动去找 ​ 现在我们获取对象时，是由工厂创建或查找得到的，是被动获得。 ​ 这种控制权交给工厂的形式就叫做控制反转（IOC） 六、Spring中的IOC​ Spring框架一大精妙之处就在于，能够帮助实现控制反转，通过配置bean对象，spring可以自动生成该对象的工厂，并且提供服务。这不仅有利于降低程序间的耦合，还大大提高了开发效率。 ​ 入门案例： ​ 通过spring中xml配bean的方式，实现dao与service对象的创建： ​ 1.导入spring依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; ​ 2.编写service与dao层的接口与实现类（省略） ​ 3.配置bean.xml文件 12345678910&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 把对象的创建交给spring来管理 --&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.Impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.itheima.dao.Impl.AccountDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; ​ 4.创建使用bean对象 12345678910public static void main(String[] args) &#123; //获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //根据id获取bean对象 IAccountService as = (IAccountService) ac.getBean(\"accountService\"); IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class); System.out.println(as); System.out.println(adao); &#125; ​ 5.（成功）测试打印结果 12com.itheima.service.Impl.AccountServiceImpl@5ea434c8com.itheima.dao.Impl.AccountDaoImpl@3bbc39f8 ​ 值得注意的·是，根据id获取bean对象时，有两种方式进行类型转换： ​ 1.强制类型转换 ​ 2.传入转后类型的字节码作为参数 六、SpringIOC的细节与bean标签​ 1.beanFactory与ApplicationContext的联系与区别： ​ BeanFactory是Spring的顶层接口，ApplicationContext是BeanFactroy的底层接口 ​ ApplicationContext接口的实现类： ​ （1）ClassPathXmlApplicationContext: ​ 从类的根路径下加载配置文件 （推荐使用） ​ （2）FileSystemXmlApplicationContext： ​ 从磁盘的路径下加载配置文件，配置文件可以在磁盘的任意位置 ​ （3）AnnotationConfigApplicationContext： ​ 使用注解配置容器对象时，需要此类来创建spring容器。它用来读取注解 ​ BeanFactroy与ApplicationConext的创建对象的时间不同： ​ （1）BeanFactory只有当对象被使用的时候，才会创建对象（延迟加载） ​ （2） ApplicationConext只要加载配置文件，就会创建对象（立即加载） ​ 2.bean标签 ​ 作用： ​ 用于配置对象，以便Spring创建。 ​ 默认情况下它调用对象类中的无参构造函数。如果没有无参构造函数则创建失败 ​ 属性： ​ （1）id：给对象在容器中提供唯一标识。用于获取对象 ​ （2）class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数 ​ （3）scope：指定对象的作为范围： ​ a) singleton: 默认值，单例的 ​ b) prototype: 多例的 ​ c) request: WEB项目中，Spring创建一个Bean对象，将对象存到request域中 ​ d）session：在WEB项目中，Spring创建一个Bean对象，将对象存到session域中 ​ e）globalSession：WEB项目中，运行在Portlet环境中，如果没有Protlet环境， globalSession相当于session ​ (4) init-method:指定类中的初始化方法名称 ​ (5) destroy-method:指定类中的销毁方法名称 ​ bean对象的作用范围与生命周期： ​ 单例对象：scope=”singleton”: ​ 一个应用只有一个对象的实例。作用范围即整个应用 ​ 生命周期： ​ 对象出生：当应用加载，创建容器时，对象就被创建了 ​ 对象活着：只要容器在，对象一直活着 ​ 对象死亡：当应用卸载，销毁容器时，对象就被销毁了 ​ 多例对象：scope=”protoType”: ​ 每次对象访问的时候，都会重新创建对象实例 ​ 生命周期： ​ 对象出生：当使用对象时，新的对象被创建 ​ 对象活着：只要对象在使用中，就一直活着 ​ 对象死亡：当对象长时间不用时，被java垃圾回收器回收了 ​ 实例化bean对象的三种方式： ​ （1）使用默认无参构造函数： 123&lt;!--在默认情况下：它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"/&gt; ​ (2)spring管理工厂–使用实例工厂的方法创建对象(当我们要创建jar包中的类时，这个类又没有无参构造函数，常常使用这种方式) 12345678910&lt;!-- 此种方式是：先把工厂的创建交给 spring 来管理。然后在使用工厂的 bean 来调用里面的方法 factory-bean 属性：用于指定实例工厂 bean 的 id。factory-method 属性：用于指定实例工厂中创建对象的方法。--&gt;&lt;bean id=\"instancFactory\" class=\"com.itheima.factory.InstanceFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"accountService\" factory-bean=\"instancFactory\" factory-method=\"createAccountService\"&gt;&lt;/bean&gt; (3) spring静态管理工厂--使用静态工厂的方法创建对象: 123456789&lt;!-- 此种方式是: 使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器 id 属性：指定 bean 的 id，用于从容器中获取 class 属性：指定静态工厂的全限定类名 factory-method 属性：指定生产对象的静态方法--&gt;&lt;bean id=\"accountService\" class=\"com.itheima.factory.StaticFactory\" factory-method=\"createAccountService\"&gt;&lt;/bean&gt; 七、Spring的依赖注入​ 依赖注入：Dependency Injection。它是Spring框架核心IOC的具体体现 ​ 我们在程序编写时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低耦合度，但不会消除耦合。例如我们的业务层仍会调用持久层的方法。 ​ 那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring去维护了/ ​ 简答的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 ​ Spring依赖注入的三种规范方式： ​ （1）构造函数注入： ​ 顾名思义，即通过调用使用类中的构造函数，给成员变量赋值。 ​ 例如某个AccountService类如下： 12345678public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125;&#125; ​ 注入方式： 123456789101112131415161718192021&lt;!-- 使用构造函数的方式，给 service 中的属性传值 要求： 类中需要提供一个对应参数列表的构造函数。 涉及的标签： constructor-arg 属性： index:指定参数在构造函数参数列表的索引位置 type:指定参数在构造函数中的数据类型 name:指定参数在构造函数中的名称 用这个找给谁赋值 =======上面三个都是找给谁赋值，下面两个指的是赋什么值的============== value:它能赋的值是基本数据类型和 String 类型 ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.Impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Data\"&gt;&lt;/bean&gt; ​ (2)set方法注入： ​ 顾名思义，就是在类中提供需要注入成员的set方法。 ​ 例如某个AccountService类如下： 1234567891011121314public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125;&#125; ​ 注入方式如下； 123456789101112131415&lt;!-- 通过配置文件给 bean 中的属性传值： 使用 set 方法的方式 涉及的标签： property 属性： name：找的是类中 set 方法后面的部分 ref：给属性赋值是其他 bean 类型的 value：给属性赋值是基本数据类型和 string 类型的 实际开发中，此种方式用的较多。--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"name\" value=\"test\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"21\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; ​ （3）使用p名称空间注入数据（本质还是调用set方法） ​ 此种方式是通过在xml种导入p名称空间，使用p：propertyName来注入数据，它的本质仍是调用类中的set方法实现注入功能。 ​ AccountService类同上 ​ 注入方式： 123456789&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl4\" p:name=\"test\" p:age=\"21\" p:birthday-ref=\"now\"/&gt;&lt;/beans&gt; ​ (4)注入集合属性 ​ 顾名思义，就是给类种的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List，Set，Map，Properties。 ​ 例如某AccountService类如下： 12345678910111213141516171819202122public class AccountServiceImpl implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125;&#125; ​ 注入方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051!-- 注入集合数据 List 结构的： array,list,set Map 结构的 map,entry,props,prop--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt; &lt;!-- 给数组注入数据 --&gt; &lt;property name=\"myStrs\"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入 list 集合数据 --&gt; &lt;property name=\"myList\"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 注入 set 集合数据 --&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入 Map 数据 --&gt; &lt;property name=\"myMap\"&gt; &lt;props&gt; &lt;prop key=\"testA\"&gt;aaa&lt;/prop&gt; &lt;prop key=\"testB\"&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 注入 properties 数据 --&gt; property name=\"myProps\"&gt; &lt;map&gt; &lt;!-- 方式1 --&gt; &lt;entry key=\"testA\" value=\"aaa\"&gt;&lt;/entry&gt; &lt;!-- 方式2 --&gt; &lt;entry key=\"testB\"&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;","categories":[],"tags":[]},{"title":"MyBatis学习笔记（四）","slug":"MyBatis学习笔记（四）","date":"2020-02-05T00:59:24.771Z","updated":"2020-02-04T08:45:08.756Z","comments":true,"path":"2020/02/05/MyBatis学习笔记（四）/","link":"","permalink":"http://yoursite.com/2020/02/05/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记（四）一、MyBatis的延迟加载​ 问题： ​ 在一对多中，我们有一个用户，它有100个账户， ​ 在查询用户时，要不要吧关联的账户查出来？ ​ 在查询账户是，要不要把关联的用户查出来？ ​ 答案： ​ 在查询用户时，用户下的账户信息应随用随查（延迟加载） ​ 在查询账户时，账户的所属用户应立即查出来（立即加载） ​ 延迟加载： ​ 在使用数据时才发起查询，不用的时候不查询，又称按需加载（懒加载） ​ 立即加载： ​ 不管用不用，只要调用方法，马上发起查询 ​ 一对多，多对多采用延迟加载 ​ 一对一，多对一采用立即加载 二、MyBatis延迟加载的实现举例： ​ 使用User与Account模型分别实现一对一与一对多的延迟加载 核心思想： ​ 将sql语句中的多表关联查询改成单表查询，并在需要访问关联数据时，再通过按需查询的方式取出关联数据。 一对一延迟加载实现： ​ 1.在sqlMapConfig.xml配置文件中打开延迟缓存的全局开关 1234&lt;settings&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"&gt;&lt;/setting&gt;&lt;/settings&gt; ​ 1.将account对象中的findAll方法的xml配置文件中的sql语句改成 1select * from account ​ 2.在IAccountDao.xml中的resultMap属性中的association中，我们不再配置id与result元素，而是添加select和colomn属性 1234567&lt;association property=\"user\" column=\"uid\" javaType=\"user\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt;&lt;/association&gt; ——–&gt; 1&lt;association property=\"user\" javaType=\"user\" select=\"com.itheima.dao.IUserDao.findUserById\" colomn=\"uid\" &gt;&lt;/association&gt; ​ 3.保证IUserDao有findUserById方法及其实现即可 一对多延迟加载实现： ​ 1.将User对象中的findAll方法的xml配置文件中的sql语句改成 1select * from user ​ 2.在IUserDao.xml中的resultMap属性中的collection中，我们不再配置id和result元素，而是添加select和colomn属性 12345&lt;collection property=\"accounts\" ofType=\"account\"&gt; &lt;id column=\"id1\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt;&lt;/collection&gt; ————&gt; 1&lt;collection type=\"accounts\" ofType=\"account\" select=\"com.itheima.dao.IAccountDao.findAccountByUid\" colomn=\"id\"&gt;&lt;/collection&gt; ​ 3.保证在IAccountDao中有findAccountByUid方法及其实现 三、MyBatis缓存​ 像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提 高性能。 ​ Mybatis 中缓存分为一级缓存，二级缓存。 一级缓存： ​ 一级缓存是 SqlSession级别的缓存，只要SqlSession 没有 flush或 close，它就存在。 一级缓存的清空 ​ 当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 二级缓存 ​ 二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个 SqlSession可以共用二级缓存，二级缓存是跨 SqlSession 的，但是保存的散装的数据，而不是完整的对象。 二级缓存的开启与关闭： ​ 1.在sqlMapConfig中开启二级缓存 123456&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt;因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false代表不开启二级缓存。 ​ 2.配置相关的Mapper映射文件 1234&lt;mapper namespace=\"com.itheima.dao.IUserDao\"&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt; ​ 3.配置statement上面的userCache属性 1234567!-- 根据 id查询 --&gt;&lt;select id=\"findById\" resultType=\"user\" parameterType=\"int\" useCache=\"true\"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt;将UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement要使用二级缓存，如果不使用二级缓存可以设置为false。 注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 四、MyBatis的注解开发​ 除了通过配置xml文件的方式，MyBatis还支持注解开发。使用注解可以简化开发，提高开发效率，但是当程序体积增大，使用注解相对更加难以维护。 ​ 注意事项： ​ 若要使用注解开发，就不能创建接口对应的xml文件，否则MyBatis将会报错。 ​ 而且注解开发在sqlMapConfig.xml中的Mapper中要配置class属性而不是resource属性。 123&lt;mappers&gt; &lt;mapper rescource=\"com/itheima/dao/IUserDao.xml\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; ———-&gt; 123&lt;mappers&gt; &lt;mapper class=\"com.itheima.dao.IUserDao\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; ​ 或者使用package也可以 123&lt;mappers&gt; &lt;package name=\"com.itheim.dao\"&gt;&lt;/package&gt;&lt;/mappers&gt; ​ 编写实现： ​ 注解开发可以省去接口对应的xml文件，采用在对应接口的方法前使用注解，并在注解括号中加入sql语句的方式来实现方法。 ​ 常用的注解有： @Insert:实现新增 ​ @Update:实现更新 ​ @Delete:实现删除 ​ @Select:实现查询 ​ @Result:实现结果集封装 ​ @Results:可以与@Result 一起使用，封装多个结果集 ​ @ResultMap:实现引用@Results 定义的封装 ​ @One:实现一对一结果集封装 ​ @Many:实现一对多结果集封装 ​ @SelectProvider: 实现动态SQL映射 ​ @CacheNamespace:实现注解二级缓存的使用 ​ 1.注解开发实现CRUD操作示例： ​ 增： 12345/** * 保存用户 */ @Insert(\"insert into user(username,birthday,sex,address)values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)\") void saveUser(User user); ​ 删： 123456/** * 删除用户 * @param id */ @Delete(\"delete from user where id =#&#123;id&#125;\") void deleteUser(Integer id); ​ 改： 123456/** * 更新用户 * @param user */ @Update(\"update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id =#&#123;id&#125;\") void updateUser(User user); ​ 查： 123456789101112131415161718192021/** * 根据id查找 * @param id * @return */ @Select(\"select * from user where id =#&#123;id&#125;\") User findById(Integer id); /** * 根据名称模糊查询 * @param username * @return */ @Select(\"select * from user where username like #&#123;username&#125;\") List&lt;User&gt; findByName(String username); /** * 查询总记录条数 * @return */ @Select(\"select count(*) from user\") Integer totalCount(); ​ 2.注解开发实现多表查询： ​ 多表查询通过注解开发也很容易实现，只需要配好@Results属性中的@Result中的@One或@Many即可。select属性配置从表被查询时会调用的方法，FetchType设置加载方式（延迟查询，立即查询） ​ 一对一： 123456789/** * 查询所有账户 * @return */ @Select(\"select * from account\") @Results(id=\"accountMap\",value=&#123; @Result(property = \"user\",column =\"uid\",one=@One(select=\"com.itheima.dao.IUserDao.findById\",fetchType = FetchType.EAGER)) &#125;) List&lt;Account&gt; fndAll(); ​ 一对多： 12345678910/** * 查询所有用户 * @return */ @Select(\"select * from user\") @Results(id=\"userMap\",value=&#123; @Result(id=true,property = \"id\",column = \"id\"), @Result(property = \"accounts\",column=\"id\",many=@Many(select=\"com.itheima.dao.IAccountDao.findByUid\",fetchType = FetchType.LAZY)) &#125;) public List&lt;User&gt; findAll(); ​ 3.注解开发使用二级缓存： ​ 不论是xml还是注解开发，一级缓存都是自动开启的。但是二级缓存，需要我们手动开启使用 ​ 开启步骤： ​ （1）在sqlMapConfig.xml中开启全局二级缓存开关（自动开启，本步骤可省略） 1234&lt;!-- 配置开启二级缓存--&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; ​ (2) 在要求开启的接口上开启二级缓存开关(写在整体接口前) 1@CacheNamespace(blocking=true) ​ 开启完毕，直接使用即可","categories":[],"tags":[]},{"title":"MyBatis学习笔记（一）","slug":"MyBatis学习笔记（一）","date":"2020-02-02T01:22:23.180Z","updated":"2020-02-02T01:03:08.330Z","comments":true,"path":"2020/02/02/MyBatis学习笔记（一）/","link":"","permalink":"http://yoursite.com/2020/02/02/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记 （一）本系列笔记学习的是黑马程序员推出的ssm系列课程，感谢老师的精彩讲解，在此立贴以示感激。 一、MyBatis概述​ MyBatis是一款优秀的Java持久层框架，它封装了JDBC，使开发者只需要关注Sql语句本身，二不需要花费精力去处理加载驱动，创建连接、创建Statement等繁杂的过程 ​ MyBatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由MyBatis框架执行sql并将结果映射为java对象并返回。 ​ 采用ORM思想解决了实体和数据库映射的问题，对JDBC进行了封装，屏蔽了JDBC API底层访问细节，是我们不用与JDBC API打交道，就可以完成对数据库的持久化操作。 二、环境搭建1.创建maven工程并导入坐标，即在pom.xml中添加依赖（包括mybatis，mysql，log4j，junit)： 2.创建数据库表以及对应的Java实体类3.创建dao接口​ 4.创建MyBatis的主配置文件（SqlMapConfig.xml):​ ​ 5.创建映射配置文件（IUserDao.xml）： 注意事项：​ 1.在MyBatis中，dao常被成为Mapper ​ 2.包与目录的创建方式不同： ​ 例如：com.itheima.IUserDao以packege方式创建是三级目录， ​ 以目录方式创建是一级目录。 ​ 3.MyBatis的映射文件和Dao接口的包结构必须相同。（即IUserDao.xml与IUserDao.java的包结构必须相同） ​ 4.映射配置文件的mapper的namespace属性必须是dao接口的全限定类名 ​ 5.映射配置文件的操作配置id属性必须是dao接口的方法名 三、入门案例### 1.步骤： 2.设计模式：3.过程分析：​ （1）解析主配置文件获取数据库连接： ​ MyBatis据此自动注册驱动，获取连接，创建connection对象​ （2）解析映射配置文件： ​ 获取执行的sql语句，MyBatis据此构造preparedStatement。 ​ （3）执行查询操作： ​ ResultSet rs = preparedStatemnt.executeQuery(); ​ (4) 遍历结果集并封装 ​ List list = new ArrayList (); ​ while(rs.next()){ ​ E element = class.forName(配置的全限定类名（即resultType）).newInstance（）; ​ 进行封装,把每个rs中的属性封装到element的属性之中 ​ 把element加入到list中 ​ list.add(element); ​ } ​ tip:在MyBatis中存在一个mapper对象，将Sql语句与封装结果的实体类全限定类名封装成一体 ​ 且存在一个map，用来保存实体类与其接口的对应关系。map的key为实体类的全限定类名（namespace属性）与接口的名称（id属性），value为sql语句与封装结果的全限定类名(resultType)。 ​ (5)返回list ​ ​ ​","categories":[],"tags":[]},{"title":"MyBatis学习笔记（三）","slug":"MyBatis学习笔记（三）","date":"2020-02-02T01:22:23.176Z","updated":"2020-02-02T00:56:23.313Z","comments":true,"path":"2020/02/02/MyBatis学习笔记（三）/","link":"","permalink":"http://yoursite.com/2020/02/02/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记（三）一、MyBatis连接池### 1.连接池：​ 在实际开发中，连接池会得到广泛应用，因为它可以减少获取连接的时间 2.MyBatis中的连接池​ MyBatis连接池提供3中方式的配置： ​ 配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性指定连接池的种类 ​ type属性取值: ​ POOLED 采用传统的javax.sql.DataSource规范中的连接池，MyBatis中有针对规范的实现 ​ UNPOOLED 采用传统的获取连接方式，虽然也实现了javax.sql.DataSource接口，但是并没有使用池的思想 ​ JNDI（*） 采用服务器提供的JNIDI技术实现，来获取DataSource对象，不同的服务器所能拿到的DataSource是不一样的，如果不是web或者maven的war工程，是不能使用的。 二、MyBatis中的事务（*自学）1.事务是什么 2.事务的四大特性ACID 3.不考虑隔离性会产生的3个问题 4.解决办法，四种隔离级别 三、MyBatis的事务自动提交MyBatis通过sqlSession对象的commit方法和rollback方法实现事务的提交和回滚 事务提交可通过调用session.commit()来提交事务,也可以通过MyBatis实现自动事务提交: 1session = factory.openSession(); 改成-&gt; 1session = factory.openSession(true); 即可 四、动态sql语句​ 在处理条件查询时，使用JDBC是一件很痛苦的事情。MyBatis提供了一种动态Sql语句的方式，来解决这个问题。为了处理这个问题，MyBatis主要提供了一下几个标签： 1.&#60;if&#62;标签​ 当查询方法传入了一个对象，要求根据对象的属性，查找数据库中与其匹配或相似的对象时，需要考虑该对象的部分属性为null或长度为0的问题。若直接用sql语句去写，很难处理。引入标签之后，可以增加一层判断，该问题就迎刃而解了。 ​ 举例：在findByUser方法中，我们传入一个User对象，要求根据用户名模糊查询，根据地址精确查寻。在原sql语句后加入“where 1=1”,再对用户名与地址是否为空进行判断，即可放心地在sql语句后完成操作。具体操作如下：(user使用了typeAlias进行了别名转换) 123456789&lt;select id = \"findByUser\" resultType=\"user\" parameter=\"user\"&gt; select * from user where 1 =1 &lt;if test =\"username!=null &amp;&amp; username.length()!=0&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test =\"address!=null\"&gt; and address = #&#123;address&#125; &lt;/if&gt; &lt;/select&gt; 2.&#60;where&#62;标签​ 简化where 1=1的条件拼装，可以采用标签来简化开发 ​ 即用标签可直接替换 where 1 = 1 1234567891011&lt;select id = \"findByUser\" resultType=\"user\" parameter=\"user\"&gt; select * from user &lt;where&gt; &lt;if test =\"username!=null &amp;&amp; username.length()!=0&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test =\"address!=null\"&gt; and address = #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3.&#60;foreach&#62;标签​ 当传入多个id查询用户信息，会使用下列sql语句： 1SELECT * FROM USERS WHERE id IN (10,89,16) ​ 当id以一个集合的形式通过参数传递传递过来时，可以使用标签，来遍历集合中的所有id，拼接完成sql语句。 ​ 具体实现： 123456789101112&lt;!-- 查询所有用户在 id的集合之中 --&gt;&lt;select id=\"findInIds\" resultType=\"user\" parameterType=\"queryvo\"&gt; &lt;!-- select * from user where id in (1,2,3,4,5); --&gt; select * from user &lt;where&gt; &lt;if test=\"ids != null and ids.size() &gt; 0\"&gt; &lt;foreach collection=\"ids\" open=\"id in ( \" close=\")\" item=\"uid\"separator=\",\"&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 标签用于遍历集合，它的属性： ​ collection:代表要遍历的集合元素，注意编写时不要写#{} ​ open:代表语句的开始部分 ​ close:代表结束部分 4. &#60;sql &#62; 标签​ 将重复的sql语句通过标签进行打包定义，后边进行引用即可 ​ 举例： ​ 定义代码片段： 1234&lt;!-- 抽取重复的语句代码片段 --&gt; &lt;sql id=\"defaultSql\"&gt; select * from user &lt;/sql&gt; ​ 引用代码片段： 1234&lt;!-- 配置查询所有操作 --&gt; &lt;select id=\"findAll\" resultType=\"user\"&gt; &lt;include refid=\"defaultSql\"&gt;&lt;/include&gt;&lt;/select&gt; 五、MyBAtis多表查询之一对多​ 举例： ​ 用户信息与账户信息是一个典型的一对多模型，一个用户可能拥有多个账户，但一个账户只能归于一个用户所有。 ​ 问题分析： ​ 我们要求实现： ​ 查询用户信息时，可以得到用户所拥有的账户信息 ​ 查询账户信息时，可以得到账户所属的用户信息 ​ 实现步骤 ​ 1.创建数据库用户表和账户表 ​ 2.创建用户实体类和账户实体类 ​ 3.创建用户配置信息和账户配置信息 ​ 4.完成配置 ​ 具体实现： ​ 账户到用户一对多： ​ 1.创建account表时需设置一个uid标识所属user对象 ​ 2..在Account类中加入User子类，并生成Getter&amp;Setter&amp;toString方法 ​ 3.IAccountDao中添加findAll方法 ​ 4.配置xml文件，用代理dao方式实现接口： ​ 定义accountUserMap: 1234567891011121314&lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"aid\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射，配置封装user的内容 --&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; ​ 引用accountUserMap，并添加sql语句： 1234&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"accountUserMap\"&gt; select a.* ,u.* from account a , user u where u.id=a.uid&lt;/select&gt; ​ 用户到账户多对一： ​ 1.在User类中加入Account集合引用，并生成Getter&amp;Setter&amp;toString方法 ​ 2.在接口中添加findAll方法 ​ 3.配置xml文件，用代理dao方式实现接口： ​ 定义userAccountMap： 1234567891011121314&lt;!-- 定义User的resultMap --&gt; &lt;resultMap id=\"userAccountMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;!-- 配置User对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"account\"&gt; &lt;id column=\"id1\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; ​ 引用userAccountMAp,并添加sql语句： 1234&lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; select * from user u left outer join account a on u.id=a.uid &lt;/select&gt; 六、MyBatis多表查询之多对多​ 举例： ​ 用户信息与角色信息是一个典型的多对多模型，一个用户可能扮演多个角色，一个角色也可能被多个用户所扮演。 ​ 问题分析： ​ 我们要求实现： ​ 查询用户信息时，可以得到用户所扮演的所有角色信息 ​ 查询角色信息时，可以得到角色所有的扮演者用户信息 ​ 实现步骤: ​ 1.创建数据库用户表和角色表以及中间关联表 ​ 2.创建用户实体类和角色实体类 ​ 3.创建用户配置信息和角色配置信息 ​ 4.完成配置 ​ 具体实现: ​ 基本步骤与上类似，此处只贴出sql语句： ​ 角色到用户: 123456&lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultMap=\"roleMap\"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt; ​ 用户到角色： 123456&lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from user u left outer join user_role ur on u.id = ur.uid left outer join role r on r.id = ur.rid &lt;/select&gt;","categories":[],"tags":[]},{"title":"MyBatis学习笔记（二）","slug":"MyBatis学习笔记（二）","date":"2020-02-02T01:22:23.173Z","updated":"2020-02-02T00:57:07.721Z","comments":true,"path":"2020/02/02/MyBatis学习笔记（二）/","link":"","permalink":"http://yoursite.com/2020/02/02/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"MyBatis学习笔记（二）一、MyBatis通过代理dao的方式实现CRUD操作1.编写步骤​ （1）在dao接口中创建相应的CRUD方法 ​ （2）配置xml文件： ​ 选择正确的标签（select insert update delete） ​ 配置id，resultType，parameter属性 ​ 配置sql语句 ​ （3）使用代理dao调用方法即可 2.parameter属性分析​ parameter属性可以设置成三种类型：简单类型，pojo对象，pojo的封装对象 ### （1）简单类型​ 直接传入简单类型名即可，不区分大小写 （2）pojo对象​ 传入对象的全限定类名。 ​ 由于MyBatis使用ognl表达式解析对象字段的值，在sql语句引用对象中的属性值时，可省略对象名.属性名的写法，直接写属性名即可 （3）pojo包装对象​ 有时查询需要用到不止一个对象的信息，则可以将多个对象封装在一个包装对象中，进行传递。 二、实体类属性与表列名不同时的转换处理​ 举例：在实体类中，User的属性为userId，userName，userAddress ​ 在数据库表中，User表的属性为id，username，address。 ​ 如果不进行一致性转换，那么resultset在封装的时候，会找不到封装目标属性，导致封装失败。 ​ 一致性转换有以下两种方法 1.改写sql语句，进行直接转换: (执行效率更高) 1select * from user ​ -&gt; 1select id as userId, username as userName, address as userAdress from user as 前时数据库表的列名，as后时java实体类的属性名 2.在映射配置文件(IUserDao.xml)中配置resultMap属性:（开发效率更高） 1234567&lt;resultMap id = \"userMap\" type = \"com.itheima.domain.User\"&gt; &lt;!-- 主键字段的对应 --&gt; &lt;id property=\"userId\" colomn=\"id\"&gt;&lt;/id&gt; &lt;!-- 非主键字段的对应 --&gt; &lt;result property=\"userName\" colomn=\"username\"&gt;&lt;/result&gt; &lt;result property=\"userAddress\" colomn=\"address\"&gt;&lt;/result&gt;&lt;/resultMap&gt; 然后在下面的各个有返回类型属性配置的sql语句配置中，使用resultMap代替resultType： 123&lt;select id=\"findAll\" resultMap=\"userMap\"&gt;select * form user&lt;/select&gt; 三、property标签的使用在配置数据库连接池的过程中需要用到property属性 12345678&lt;!-- 配置数据源(连接池) --&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/dataSource&gt; 也可以通过外联配置文件的方式来进行配置，此时需用properties标签指定外联配置文件的路径，再将property中的value改成引用的形式即可 123&lt;!-- jdbcConfig.properties中指定了数据库连接所需的driver,url,username,password等属性--&gt;&lt;properties resource = \"jdbcConfig.properties\"&gt;&lt;/properties&gt; 12345678&lt;!-- 配置数据源(连接池) --&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的基本信息 --&gt; &lt;property name=\"driver\" value=“$&#123;jdbc.driver&#125;”&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; 四、typeAlias与packege标签的使用typeAlias标签用于配置domain中类的别名，即可将全限定类名配置别名，使其使用更加简单: 12345&lt;typeAliases&gt; &lt;!-- type指定实体类的全限定类名，name指定别名 --&gt; &lt;!-- 配置别名之后，使用别名可以不再区分大小写 --&gt; &lt;typealias type=\"com.itheim.domain.user\" name=\"user\"&gt;&lt;/typealias&gt;&lt;/typeAliases&gt; 标签用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且别名就是类名。 同样，别名不再区分大小写 1234&lt;typeAliases&gt; &lt;package name=\"com.itheima.domain\"&gt;&lt;/package&gt;&lt;/typeAliases&gt;&lt;!--配置之后，domain下的所有实体类都被配置了别名，例如com.itheima.domain.user的别名为user--&gt;","categories":[],"tags":[]},{"title":"操作系统（七）--死锁","slug":"操作系统（七）-死锁","date":"2019-11-06T11:59:31.000Z","updated":"2019-11-06T15:08:57.088Z","comments":true,"path":"2019/11/06/操作系统（七）-死锁/","link":"","permalink":"http://yoursite.com/2019/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89-%E6%AD%BB%E9%94%81/","excerpt":"","text":"本篇博客分享《操作系统概念》中第七章–死锁部分的学习笔记。死锁是操作系统设计过程中必须着重考虑的一个环节，处理不得当会导致操作系统吞吐量大幅度降低，响应速度慢的结果。作为计算机学习者，我们应该掌握死锁的基本原理，以及如何处理死锁问题。 定义死锁的概念并不难理解，定义如下： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去 必要条件 互斥(mutual exclusion): 至少有一个资源是非共享的，即一次只有一个进程可以使用。这使得一个进程可能为了这个资源而等待另一个占有该资源的进程 占有并等待(hold and wait): 一个进程至少占有一个资源，并等待另一个资源。死锁是由许多进程各自占有对方的资源，又互不相让导致的。一个不占有资源的进程是不会导致死锁的。 非抢占(no preemption): 资源不能抢占。各个进程不给对方资源，却又很礼貌，不抢对方的资源。抢占式资源分配很少出现死锁 循环等待（circle wait）： 有一组等待进程{P0 , P1 , … , Pn},P0等待的资源为P1占有，P1等待的资源为P2占有, …… ,Pn-1等待的资源为Pn占有，Pn等待的资源为P0占有。死锁的资源分配图呈环状 死锁处理方法一般来说，死锁有四种处理方法: 1. 死锁预防 2. 死锁避免 3. 死锁检测与恢复 4. 忽略死锁，手动操作实际上，第四种处理方法看似称不上解决方案，但恰恰为大多数操作系统所采用，包括Linux和Windows。其中，处理死锁的代价是一个重要考量因素。对于许多系统，死锁出现频率很低（甚至一年一次），若使用频繁且开销昂贵的死锁预防、避免或是检测，会浪费大量资源，导致效率低下。相比之下，不处理却是最好的处理，开发人员需自行编写程序，处理死锁即可。 作为学习的需要，了解前三种死锁处理的机制以及分析它们的优缺点对我们大有裨益，以下将详细介绍这三种机制。 死锁预防死锁预防主要从死锁的四个必要条件入手，从根源阻断死锁的产生 互斥 可共享文件不要求互斥访问，因此不会产生死锁。 可读文件便是共享文件的一个例子，当多个文件试图共同读一个文件时，不会产生死锁的问题 但是通常不能通过互斥的角度预防死锁，因为很多资源本身就是非共享的，如互斥锁 持有并等待 该解决方案可理解为all or zero。即每个进程申请资源时，要么获得所有需要的资源，要么什么也得不到。 这种方案确实可以解决死锁问题，但是可能导致资源利用率低与饥饿两种问题 非抢占 改变系统为可抢占模式，则资源不会锁死在不同进程中，可以集中起来服务少数进程，并最终服务完所有进程。 这个协议通常用于状态可保存和恢复的资源，如CPU寄存器和内存。一般不适用于其他资源，如互斥锁和信号量 循环等待 将资源类型完全排序，并要求每个进程按递增顺序来申请资源，这样可以避免资源等待图中环的发生。 但是，设计一个完全排序或层次结构本身不能防止死锁，还要靠应用程序员按顺序编写程序。另外资源排序方式应该按正常使用顺序编排，不可随意排序。 死锁避免1.资源分配图算法 在一个每种资源只有一个实例的资源分配系统中，可用特殊的资源分配图来避免死锁。特殊资源分配图： 除了申请边和分配边（实线），我们引入一个需求边（虚线）。需求边Pi -&gt; Rj表示，进程Pj可能在将来某个时候申请资源Rj。 当请求发生时，需求边变成申请边。 当Pi释放Rj时，分配边变成需求边。 算法依据： 资源分配图中无环，则一定处于安全状态。 资源分配图中有环，则可能处于非安全状态。 算法描述： 假设Pi申请Rj。只有当申请边Pi-&gt;Rj变成分配边Rj-&gt;Pi并且资源分配图中不出现环是，才能允许申请。 银行家算法 适用于每种资源类型有多个实例的资源分配系统。该算法可用于银行系统，可确保银行不会分配现金，以致于它不再满足所有客户的需要。 算法描述： 当一个新的进程进入系统时，它应申明可能需要的每种类型资源实例的最大数量，这一数量不能超过系统资源的总和。当某进程申请一组资源时，系统应确定这些资源的分配是否会使系统不再安全。若是，则该进程等待，直到其他进程释放更多资源。否则，分配资源。 死锁检测 每种资源类型只有单个实例： 维护等待图。当且仅当等待图中有环，出现死锁。 每种资源类型有多个实例： 维护类似于银行家算法的多个矩阵图。比较Need矩阵与available向量的大小。 死锁恢复 进程终止1） 终止所有进程：可打破死锁，但是代价巨大。当进程重新计算时，要耗费大量的时间。2） 逐个终止进程，直至消除死锁循环：每次终止一个进程，都将调用死锁检测算法，开销大。并且指定规则，确定每次终止的进程。 资源抢占 资源抢占可解决死锁问题，但是要处理好三个问题： 1） 如何选择牺牲进程：根据代价最小原则确定抢占顺序 2） 回滚：合理处理被抢占进程 3） 饥饿：应设置进程被抢占次数的上限，避免其被无限抢占而节。","categories":[],"tags":[]},{"title":"计算机网络--逻辑链路层","slug":"逻辑链路层","date":"2019-11-05T03:52:24.000Z","updated":"2019-11-06T08:09:18.281Z","comments":true,"path":"2019/11/05/逻辑链路层/","link":"","permalink":"http://yoursite.com/2019/11/05/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"一、概述 数据链路层使用物理层提供的服务在通信信道上发送和接受比特。 二、功能 向网络层提供一个定义良好的服务接口 处理传输错误 调节数据流，确保慢速的接收方不会被快速的接收方淹没 三、服务向网络层提供以下三种服务： 无确认的无连接服务 有确认的无连接服务 有确认的有连接服务 四、成帧 字节计数法 字节填充的标志字节法: 用标志字节FLAG来代表一帧的开始和结束，并用转义字符ESC来解决透明传输问题 例题: Answer: ESC ESC C ESC ESC ESC FLAG G ESC FLAG D 比特填充的标志比特法011111110或十六进制0x7E作为标志字节。若传输的数据遇到连续五个1，则在其后添加一个0，打断六个以上的连续1字节流 物理层编码违禁法","categories":[],"tags":[]}]}